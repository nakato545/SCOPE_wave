<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <title>波シミュレーション</title>
  <style>
    :root {
      --scale-factor: 1;
    }
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100vh;
      overflow: hidden; background: #f0f2f5;
      font-family: -apple-system, "Helvetica Neue", "Hiragino Kaku Gothic ProN", sans-serif;
    }

    /* 画面の向き警告（ガタつき修正版） */
    #orientation-warning {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #ffffff; z-index: 999999; color: #000000; flex-direction: column;
      justify-content: center; align-items: center; text-align: center; padding: 20px; box-sizing: border-box;
    }
    .rotate-icon {
      width: 44px; height: 88px;
      border: 3px solid #000; border-radius: 8px;
      position: relative; margin-bottom: 25px;
      background: #fff;
      animation: rotate-anim 2s infinite ease-in-out;
      box-sizing: border-box;
    }
    .rotate-icon::before {
      content: ""; position: absolute; top: 0; left: 50%; transform: translateX(-50%);
      width: 18px; height: 4px; background: #000; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px;
    }
    .rotate-icon::after {
      content: ""; position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%);
      width: 14px; height: 2px; background: #000; border-radius: 1px;
    }

    /* 警告文字の配置を他と揃える */
    #orientation-warning p {
      display: flex !important; justify-content: center; align-items: flex-end !important;
      gap: 0.1em; font-weight: bold; font-size: 20px; margin: 0; line-height: 1.2;
    }
    #orientation-warning ruby { display: inline-flex !important; flex-direction: column-reverse !important; align-items: center !important; vertical-align: bottom !important; }
    #orientation-warning rt { display: block !important; font-size: 10px !important; line-height: 1 !important; margin-bottom: 3px !important; visibility: visible !important; height: auto !important; }

    @keyframes rotate-anim { 0% { transform: rotate(0deg); } 30%, 100% { transform: rotate(-90deg); } }
    @media screen and (orientation: portrait) { #orientation-warning { display: flex !important; } }

    /* ロード画面 */
    #loading {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: white; display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 99999;
      transition: opacity 1s ease;
    }
    .logo-container { position: relative; display: inline-block; }
    #loading img { width: 180px; height: auto; display: block; }
    .loading-text { position: absolute; right: 0; bottom: -25px; font-family: sans-serif; font-size: 14px; font-weight: bold; color: #555; letter-spacing: 1px; animation: blink 1.2s infinite; }
    @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.1; } 100% { opacity: 1; } }
    #loading.fade-out { opacity: 0; pointer-events: none; }

    /* ルび共通設定 */
    ruby { display: inline-flex; flex-direction: column-reverse; vertical-align: bottom; line-height: 1; height: auto; justify-content: flex-end; text-align: center; }
    rb { display: block; line-height: 1.2; }
    rt { display: block; font-size: 0.55em; line-height: 1.1; margin-bottom: 2px; color: #000; visibility: visible; }
    rt.dummy { color: transparent; }

    /* ナビゲーション */
    #sideNav { 
      position: fixed; top: 10px; right: 10px; z-index: 9999; 
      display: flex; flex-direction: column; gap: 5px; 
    }
    .nav-btn {
      text-decoration: none; color: black; background: white;
      border: 1.5px solid black; border-radius: 8px; font-size: calc(11px * var(--scale-factor));
      font-weight: bold; width: calc(75px * var(--scale-factor)); height: calc(45px * var(--scale-factor));
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .nav-btn.active { background: #e9e5ff; border-color: #0000ff; }

    /* メインレイアウト */
    #contentContainer {
      display: flex; flex-direction: column; align-items: center; justify-content: space-between;
      width: 100%; height: 100vh; padding: 10px; box-sizing: border-box;
    }

    #canvasWrapper { 
      position: relative; width: 100%; max-width: 900px;
      flex-grow: 1; overflow: hidden; display: flex; justify-content: center; align-items: center;
    }
    #canvas { display:block; background:white; border-bottom: 2px solid #ccc; touch-action: none; width: 100%; height: 100%; }

    /* UIパネル */
    #mainPanel {
      position: relative; width: 100%; max-width: 700px; height: auto;
      background: rgba(255,255,255,0.98); border: 2px solid black; 
      border-radius: 15px; display: flex; flex-wrap: wrap; padding: calc(8px * var(--scale-factor)); gap: 6px; 
      z-index: 100; box-shadow: 0 5px 20px rgba(0,0,0,0.15); box-sizing: border-box; align-items: center;
      margin-bottom: 5px;
    }

    .setting-panel {
      position: absolute; bottom: 110%;
      left: 50%; transform: translateX(-50%);
      width: 96%; max-width: 500px; 
      background: white; border: 2px solid black; border-radius: 15px;
      padding: 12px; z-index: 90; box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      display: none; flex-direction: column; gap: 10px; box-sizing: border-box;
    }
    .setting-panel.open { display: flex; }

    .ui-row { display: flex; align-items: center; gap: 8px; width: 100%; }
    .label-box { min-width: 45px; font-size: 12px; font-weight: bold; color: #444; }
    .btn-pair { display: flex; gap: 5px; flex: 1; height: calc(48px * var(--scale-factor)); }
    .ui-btn { border: 1.5px solid black; border-radius: 10px; background: white; cursor: pointer; font-size: 13px; display: flex; align-items: center; justify-content: center; box-sizing: border-box; font-weight: bold; width: 100%; height: 100%; }
    .ui-btn.active { background: #e9e5ff !important; border-color: #0000ff; }
    .main-btn { height: calc(52px * var(--scale-factor)); }

    #manualText { font-size: 12px; color: #333; text-align: center; border: 1.5px dashed #bbb; padding: 6px; border-radius: 10px; background: #fafafa; display: flex; align-items: center; justify-content: center; min-height: 40px; }
    #playGuide { position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%); z-index: 2000; pointer-events: none; background: rgba(0, 0, 0, 0.7); color: white; padding: 12px 24px; border-radius: 30px; font-weight: bold; opacity: 0; transition: opacity 0.3s ease; }
    #playGuide.show { opacity: 1; }

    .slider-group { flex: 1; }
    .slider-info { display: flex; justify-content: space-between; font-weight: bold; font-size: 10px; margin-bottom: 1px; }
    .val-display { font-family: monospace; font-size: 12px; color: #0000ff; }
    input[type="range"] { width: 100%; height: 18px; cursor: pointer; }

    .modal { display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); }
    .modal-content { background: white; margin: 10% auto; padding: 20px; border: 2px solid black; border-radius: 20px; width: 85%; max-width: 500px; }
    .close { float: right; font-size: 32px; cursor: pointer; }
  </style>
</head>
<body>

  <div id="orientation-warning">
    <div class="rotate-icon"></div>
    <p><ruby>画<rt>が</rt></ruby><ruby>面<rt>めん</rt></ruby>を<ruby>横<rt>よこ</rt></ruby>にしてください</p>
  </div>

  <div id="loading">
    <div class="logo-container">
      <img src="SCOPEロゴ通常版-768x768.webp" alt="SCOPEロゴ">
      <div class="loading-text">LOADING...</div>
    </div>
  </div>

  <div id="sideNav">
    <a href="index.html" class="nav-btn"><ruby>ホ<rt class="dummy">・</rt></ruby><ruby>ー<rt class="dummy">・</rt></ruby><ruby>ム<rt class="dummy">・</rt></ruby></a>
    <div class="nav-btn" onclick="showModal('howto')"><ruby>使<rt>つか</rt></ruby><ruby>い<rt class="dummy">・</rt></ruby><ruby>方<rt>かた</rt></ruby></div>
    <div class="nav-btn" onclick="showModal('guide')"><ruby>解<rt>かい</rt></ruby><ruby>説<rt>せつ</rt></ruby></div>
    <div class="nav-btn active" id="btnTheory" onclick="toggleTheoryBackground()"><ruby>背<rt>はい</rt></ruby><ruby>景<rt>けい</rt></ruby></div>
  </div>

  <div id="contentContainer">
    <div id="canvasWrapper"><canvas id="canvas"></canvas></div>

    <div id="mainPanel">
      <div id="typePanel" class="setting-panel">
        <div class="ui-row">
          <div class="label-box"><ruby>種<rt>しゅ</rt></ruby><ruby>類<rt>るい</rt></ruby></div>
          <div class="btn-pair">
            <div class="ui-btn active" id="btnTrans" onclick="setWaveType('trans')"><ruby>横<rt>よこ</rt></ruby><ruby>波<rt>なみ</rt></ruby></div>
            <div class="ui-btn" id="btnLong" onclick="setWaveType('long')"><ruby>縦<rt>たて</rt></ruby><ruby>波<rt>なみ</rt></ruby></div>
          </div>
        </div>
      </div>

      <div id="detailPanel" class="setting-panel">
        <div class="ui-row">
          <div class="label-box"><ruby>端<rt>はし</rt></ruby></div>
          <div class="btn-pair">
            <div class="ui-btn active" id="btnFixedEnd" onclick="setEnd('fixed')"><ruby>固<rt>こ</rt></ruby><ruby>定<rt>てい</rt></ruby></div>
            <div class="ui-btn" id="btnFreeEnd" onclick="setEnd('free')"><ruby>自<rt>じ</rt></ruby><ruby>由<rt>ゆう</rt></ruby></div>
          </div>
        </div>
        <div class="ui-row">
          <div class="label-box"><ruby>操<rt>そう</rt></ruby><ruby>作<rt>さ</rt></ruby></div>
          <div class="btn-pair">
            <div class="ui-btn active" id="btnManual" onclick="setDrive('manual')"><ruby>手<rt>しゅ</rt></ruby><ruby>動<rt>どう</rt></ruby></div>
            <div class="ui-btn" id="btnAuto" onclick="setDrive('auto')"><ruby>自<rt>じ</rt></ruby><ruby>動<rt>どう</rt></ruby></div>
          </div>
        </div>
        <div id="sliderArea" style="display:none; margin-top: 2px;">
          <div class="ui-row" style="gap:15px;">
            <div class="slider-group">
              <div class="slider-info"><span><ruby>振<rt>しん</rt></ruby><ruby>幅<rt>ぷく</rt></ruby></span><span id="ampDisplay" class="val-display">40</span></div>
              <input type="range" min="10" max="60" value="40" id="ampSlider">
            </div>
            <div class="slider-group">
              <div class="slider-info"><span><ruby>周<rt>しゅう</rt></ruby><ruby>波<rt>は</rt></ruby><ruby>数<rt>すう</rt></ruby></span><span id="freqDisplay" class="val-display">1.00</span></div>
              <input type="range" min="0.5" max="3" step="0.01" value="1" id="freqSlider">
            </div>
          </div>
        </div>
        <div id="manualText"></div>
      </div>

      <div class="ui-btn active main-btn" id="btnPlayPause" onclick="togglePlayPause()" style="flex:2.5;"><ruby>再<rt>さい</rt></ruby><ruby>生<rt>せい</rt></ruby> / <ruby>停<rt>てい</rt></ruby><ruby>止<rt>し</rt></ruby></div>
      <div class="ui-btn main-btn" id="btnSlow" onclick="toggleSlow()" style="flex:1;"><ruby>ス<rt class="dummy">・</rt></ruby><ruby>ロ<rt class="dummy">・</rt></ruby><ruby>ー<rt class="dummy">・</rt></ruby></div>
      <div class="ui-btn main-btn" id="btnReset" onclick="resetWave()" style="flex:1;"><ruby>リ<rt class="dummy">・</rt></ruby><ruby>セ<rt class="dummy">・</rt></ruby><ruby>ッ<rt class="dummy">・</rt></ruby><ruby>ト<rt class="dummy">・</rt></ruby></div>
      <div class="ui-btn main-btn" id="btnOpenDetail" onclick="toggleDetail(); event.stopPropagation();" style="flex:1.2; background: #eee;"><ruby>設<rt>せっ</rt></ruby><ruby>定<rt>てい</rt></ruby>⚙</div>
      <div class="ui-btn main-btn" id="btnOpenType" onclick="toggleTypePanel(); event.stopPropagation();" style="flex:1.2; background: #eee;"><ruby>種<rt>しゅ</rt></ruby><ruby>類<rt>るい</rt></ruby></div>
    </div>
  </div>

  <div id="playGuide"><ruby>再<rt>さい</rt></ruby><ruby>生<rt>せい</rt></ruby><ruby>ボ<rt class="dummy">・</rt></ruby><ruby>タ<rt class="dummy">・</rt></ruby><ruby>ン<rt class="dummy">・</rt></ruby>を<ruby>押<rt>お</rt></ruby>してね！</div>

  <div id="infoModal" class="modal">
    <div class="modal-content"><span class="close" onclick="closeModal()">&times;</span><h3 id="modalTitle"></h3><div id="modalBody"></div></div>
  </div>

  <script>
    const orientWarning = document.getElementById("orientation-warning");
    function checkOrientation() {
      const isLandscape = window.innerWidth > window.innerHeight;
      orientWarning.style.display = isLandscape ? "none" : "flex";
    }
    window.addEventListener("resize", () => { checkOrientation(); adjustLayoutScale(); });

    function adjustLayoutScale() {
      const vh = window.innerHeight;
      const baseHeight = 520; 
      const scale = Math.min(1.2, Math.max(0.7, vh / baseHeight));
      document.documentElement.style.setProperty('--scale-factor', scale);
      resizeCanvas(); 
    }
    window.addEventListener('load', () => { checkOrientation(); adjustLayoutScale(); });

    let guideTimer = null;
    function triggerPlayGuide() {
      if (playing) return;
      const guide = document.getElementById("playGuide");
      guide.classList.add("show");
      if (guideTimer) clearTimeout(guideTimer);
      guideTimer = setTimeout(() => { guide.classList.remove("show"); guideTimer = null; }, 2500);
    }

    function toggleTypePanel() {
      const panel = document.getElementById("typePanel"), btn = document.getElementById("btnOpenType");
      document.getElementById("detailPanel").style.display = "none";
      document.getElementById("btnOpenDetail").classList.remove("active");
      const isOpen = (panel.style.display === "flex");
      panel.style.display = isOpen ? "none" : "flex";
      btn.classList.toggle("active", !isOpen);
    }
    function toggleDetail() {
      const panel = document.getElementById("detailPanel"), btn = document.getElementById("btnOpenDetail");
      document.getElementById("typePanel").style.display = "none";
      document.getElementById("btnOpenType").classList.remove("active");
      const isOpen = (panel.style.display === "flex");
      panel.style.display = isOpen ? "none" : "flex";
      btn.classList.toggle("active", !isOpen);
    }

    window.addEventListener("load", () => { setTimeout(() => { document.getElementById("loading").classList.add("fade-out"); }, 800); });

    function showModal(type) {
      const title = document.getElementById("modalTitle"), body = document.getElementById("modalBody");
      if(type === 'guide') { title.innerHTML = "<ruby>解<rt>かい</rt></ruby><ruby>説<rt>せつ</rt></ruby>"; body.innerHTML = "波の伝播シミュレーションです。"; } 
      else if(type === 'howto') { title.innerHTML = "使いかた"; body.innerHTML = "1. 手動: 点をドラッグ。 2. 自動: サイン波。"; }
      document.getElementById("infoModal").style.display = "block";
    }
    function closeModal() { document.getElementById("infoModal").style.display = "none"; }

    function updateManualText() {
      const target = document.getElementById("manualText");
      const color = (waveType === "trans") ? {t:"赤", r:"あか"} : {t:"青", r:"あお"};
      target.innerHTML = `<ruby>${color.t}<rt>${color.r}</rt></ruby>い点を動かして波を描こう！`;
    }

    const imgSky = new Image(); imgSky.src = "sky.png";
    const imgSea = new Image(); imgSea.src = "sea.png";
    const imgMusical = new Image(); imgMusical.src = "musical.png";
    const imgPlay = new Image(); imgPlay.src = "play.png";
    const imgNote = new Image(); imgNote.src = "note.png";

    const SKY_IMG_HEIGHT = 500, SEA_IMG_HEIGHT = 500, MUSICAL_IMG_HEIGHT = 400, BG_X_OFFSET = 15;
    let showBackground = true, driveType = "manual", playing = true;
    const canvas = document.getElementById("canvas"), ctx = canvas.getContext("2d");
    const ampSlider = document.getElementById("ampSlider"), freqSlider = document.getElementById("freqSlider");
    const ampDisplay = document.getElementById("ampDisplay"), freqDisplay = document.getElementById("freqDisplay");

    let waveType = "trans", endType = "fixed", margin = 70, marginRight = 110, N = 240, y = new Array(N).fill(0), v = new Array(N).fill(0), dragging = false;
    const damping = 0.998, c = 2.0;

    let currentSpeedScale = 1.0, theta = 0, currentAmp = 40, currentFreq = 1.0, currentOmega = 2*Math.PI*currentFreq;
    let pendingAmp = 40, pendingFreq = 1.0, hasPending = false;
    let speedRamp = { active:false, start:1.0, end:1.0, elapsed:0, duration:0.35 };
    let ampRamp = { active:false, startAmp:40, endAmp:40, progress:0, durationSec:1 };
    let accel = { active:false, targetOmega:currentOmega, accelValue:0, timeLeft:0 };
    let driverTarget = 0, manualInertiaVel = 0, manualRawTarget = 0, manualFilteredTarget = 0;
    const manualTau = 0.015;
    let noteFade = 0.0;

    function lerp(a,b,t){ return a + (b-a)*t; }
    function smoothstep(t){ return t<=0?0:t>=1?1:t*t*(3-2*t); }
    function getLimit() { return Math.max(10, Math.min(60, (canvas.height / 2) - 20)); }

    function resizeCanvas(){ const wrapper = document.getElementById("canvasWrapper"); if (!wrapper) return; canvas.width = wrapper.clientWidth; canvas.height = wrapper.clientHeight; }

    function resetWave(){ y.fill(0); v.fill(0); theta = 0; currentAmp = pendingAmp = parseFloat(ampSlider.value); currentFreq = pendingFreq = parseFloat(freqSlider.value); currentOmega = 2*Math.PI*currentFreq; ampRamp.active = false; hasPending = false; accel.active = false; driverTarget = 0; manualInertiaVel = 0; manualRawTarget = 0; manualFilteredTarget = 0; noteFade = 0; }

    function toggleTheoryBackground() { showBackground = !showBackground; document.getElementById("btnTheory").classList.toggle("active", showBackground); }
    
    function setWaveType(type){ waveType = type; resetWave(); document.getElementById("btnTrans").classList.toggle("active", type==="trans"); document.getElementById("btnLong").classList.toggle("active", type==="long"); updateManualText(); }
    
    function setDrive(type){ if(type === "manual" && driveType === "auto") manualInertiaVel = currentAmp * currentOmega * Math.cos(theta); else manualInertiaVel = 0; manualRawTarget = y[0]; manualFilteredTarget = y[0]; driverTarget = y[0]; driveType = type; document.getElementById("btnManual").classList.toggle("active", type==="manual"); document.getElementById("btnAuto").classList.toggle("active", type==="auto"); const sa = document.getElementById("sliderArea"), mt = document.getElementById("manualText"); if(type === "manual") { sa.style.display = "none"; mt.style.display = "flex"; } else { sa.style.display = "block"; mt.style.display = "none"; } updateManualText(); }
    
    function setEnd(type){ endType = type; document.getElementById("btnFixedEnd").classList.toggle("active", type==="fixed"); document.getElementById("btnFreeEnd").classList.toggle("active", type==="free"); }

    function handlePointer(e) { if(driveType !== "manual") return; if(!playing) triggerPlayGuide(); const rect = canvas.getBoundingClientRect(); const clientX = (e.touches ? e.touches[0].clientX : e.clientX), clientY = (e.touches ? e.touches[0].clientY : e.clientY); const cx = clientX - rect.left, cy = clientY - rect.top; const limit = getLimit(); if (waveType === "trans") { manualRawTarget = Math.max(-limit, Math.min(limit, cy - canvas.height/2)); } else { manualRawTarget = Math.max(-limit, Math.min(limit, cx - margin)); } }

    canvas.addEventListener("mousedown", e => { dragging = true; handlePointer(e); manualFilteredTarget = manualRawTarget; manualInertiaVel = 0; });
    window.addEventListener("mousemove", e => { if(dragging) handlePointer(e); });
    window.addEventListener("mouseup", () => dragging = false);
    canvas.addEventListener("touchstart", e => { e.preventDefault(); dragging = true; handlePointer(e); manualFilteredTarget = manualRawTarget; manualInertiaVel = 0; }, {passive:false});
    canvas.addEventListener("touchmove", e => { e.preventDefault(); if(dragging) handlePointer(e); }, {passive:false});
    canvas.addEventListener("touchend", () => dragging = false);

    ampSlider.oninput = ()=>{ ampDisplay.textContent = ampSlider.value; pendingAmp = parseFloat(ampSlider.value); hasPending = true; };
    freqSlider.oninput = ()=>{ freqDisplay.textContent = Number(freqSlider.value).toFixed(2); pendingFreq = parseFloat(freqSlider.value); hasPending = true; };
    
    function togglePlayPause(){ playing = !playing; document.getElementById("btnPlayPause").classList.toggle("active", playing); if(playing) { document.getElementById("playGuide").classList.remove("show"); if(guideTimer) { clearTimeout(guideTimer); guideTimer = null; } } }
    function toggleSlow(){ let isSlow = (speedRamp.active ? speedRamp.end < 1.0 : currentSpeedScale < 1.0); document.getElementById("btnSlow").classList.toggle("active", !isSlow); speedRamp = { active:true, start:currentSpeedScale, end:isSlow?1.0:0.25, elapsed:0, duration:0.35 }; }

    function update(){
      if(!playing) return;
      const frameBaseSec = 0.016;
      if(speedRamp.active){ speedRamp.elapsed += frameBaseSec; let tr = Math.min(1, speedRamp.elapsed / speedRamp.duration); currentSpeedScale = lerp(speedRamp.start, speedRamp.end, smoothstep(tr)); if(tr >= 1){ currentSpeedScale = speedRamp.end; speedRamp.active = false; } }
      const deltaRealSec = frameBaseSec * currentSpeedScale;
      if(accel.active){ if(deltaRealSec >= accel.timeLeft){ currentOmega = accel.targetOmega; accel.active = false; } else { currentOmega += accel.accelValue * deltaRealSec; accel.timeLeft -= deltaRealSec; } }
      theta += currentOmega * deltaRealSec;
      if(hasPending){ const newOmega = 2*Math.PI*pendingFreq; const accelDuration = 1 / pendingFreq; accel = { active:true, targetOmega:newOmega, timeLeft:accelDuration, accelValue:(newOmega - currentOmega) / accelDuration }; ampRamp = { active:true, startAmp:currentAmp, endAmp:pendingAmp, progress:0, durationSec:accelDuration }; hasPending = false; }
      if(ampRamp.active){ ampRamp.progress += deltaRealSec / ampRamp.durationSec; currentAmp = lerp(ampRamp.startAmp, ampRamp.endAmp, smoothstep(Math.min(1, ampRamp.progress))); if(ampRamp.progress >= 1) ampRamp.active = false; }
      
      if(driveType === "auto") { const limit = getLimit(); let target = (currentAmp / 60) * limit * Math.sin(theta); driverTarget += (target - driverTarget) * (1 - Math.exp(-deltaRealSec / 0.04)); }
      else if(dragging){ manualFilteredTarget += (manualRawTarget - manualFilteredTarget) * (1 - Math.exp(-deltaRealSec / manualTau)); driverTarget = manualFilteredTarget; }
      else { if (Math.abs(driverTarget) > 0.01 || Math.abs(manualInertiaVel) > 0.1) { manualInertiaVel += (-150 * driverTarget) * deltaRealSec; manualInertiaVel *= Math.pow(0.45, deltaRealSec * 60); driverTarget += manualInertiaVel * deltaRealSec; } else { driverTarget = 0; } }
      y[0] = driverTarget;
      const phDt = 0.5 * currentSpeedScale;
      for(let i=1;i<N-1;i++){ v[i] += c*c*(y[i+1] + y[i-1] - 2*y[i]) * phDt; v[i] *= damping; }
      for(let i=1;i<N-1;i++) y[i] += v[i] * phDt;
      if(endType === "fixed"){ y[N-1] = 0; v[N-1] = 0; } else { y[N-1] = y[N-2]; v[N-1] = v[N-2]; }
      const isMoving = Math.abs(y[0]) > 0.5 || (driveType === "auto" && playing);
      if (isMoving) { noteFade = Math.min(1.0, noteFade + 0.05); } else { noteFade = Math.max(0.0, noteFade - 0.03); }
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const waveAreaWidth = canvas.width - margin - marginRight, centerY = canvas.height / 2, limit = getLimit();

      if (waveType === "trans") {
        if (showBackground) {
          const bgX = margin + BG_X_OFFSET, bgW = waveAreaWidth - BG_X_OFFSET;
          ctx.save(); ctx.beginPath(); ctx.moveTo(bgX, canvas.height);
          for(let i=0; i<N; i++){ let px = margin + i * waveAreaWidth / (N-1); if(px >= bgX) ctx.lineTo(px, centerY + y[i]); }
          ctx.lineTo(margin + waveAreaWidth, canvas.height); ctx.clip();
          ctx.drawImage(imgSea, bgX, (centerY - SEA_IMG_HEIGHT/2) -50, bgW, SEA_IMG_HEIGHT); ctx.restore();
          ctx.save(); ctx.beginPath(); ctx.moveTo(bgX, 0);
          for(let i=0; i<N; i++){ let px = margin + i * waveAreaWidth / (N-1); if(px >= bgX) ctx.lineTo(px, centerY + y[i]); }
          ctx.lineTo(margin + waveAreaWidth, 0); ctx.clip();
          ctx.drawImage(imgSky, bgX, (centerY - SKY_IMG_HEIGHT/2) +25, bgW, SKY_IMG_HEIGHT); ctx.restore();
        }
        ctx.strokeStyle = "#ccc"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(margin, centerY - limit); ctx.lineTo(margin, centerY + limit); ctx.stroke();
        ctx.strokeStyle = "black"; ctx.lineWidth = 2; ctx.beginPath(); for(let i=0;i<N;i++) ctx.lineTo(margin + i*waveAreaWidth/(N-1), centerY + y[i]); ctx.stroke();
        ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(margin, centerY + y[0], 6, 0, Math.PI*2); ctx.fill();
        if(endType === "fixed"){ ctx.fillStyle = "#aaa"; ctx.fillRect(margin + waveAreaWidth, centerY - limit - 20, 4, (limit * 2) + 40); }
      } else {
        const h = 24, sliceW = waveAreaWidth / (N - 1);
        if (showBackground) {
          ctx.save(); ctx.globalAlpha = 0.5;
          const safeZone = 110, targetX = margin + safeZone, targetW = waveAreaWidth - safeZone, targetY = centerY - MUSICAL_IMG_HEIGHT / 2;
          if (targetW > 20) {
            ctx.beginPath(); ctx.rect(targetX, targetY, targetW, MUSICAL_IMG_HEIGHT); ctx.clip();
            const imgAspect = (imgMusical.width || 100) / (imgMusical.height || 100);
            let dW = targetW, dH = targetW / imgAspect; if (dH < MUSICAL_IMG_HEIGHT) { dH = MUSICAL_IMG_HEIGHT; dW = dH * imgAspect; }
            ctx.drawImage(imgMusical, targetX + (targetW - dW)/2, targetY + (MUSICAL_IMG_HEIGHT - dH)/2, dW, dH);
          }
          ctx.restore();
          if (waveAreaWidth > 200) {
            ctx.drawImage(imgPlay, margin + safeZone + 20, centerY + 40, 150, 150);
            if (noteFade > 0) { ctx.save(); ctx.globalAlpha = (0.55 + 0.15 * Math.sin(Date.now() / 250)) * noteFade; ctx.drawImage(imgNote, margin + safeZone + 180, centerY + 50, 130, 130); ctx.restore(); }
          }
        }
        for (let i = 0; i < N - 1; i++) {
          const dx = ((i + 1) * sliceW + y[i + 1]) - (i * sliceW + y[i]), compression = sliceW / dx;
          let gray, alpha; if (compression >= 1.0) { let weight = Math.min(1.0, (compression - 1.0) * 3.0); gray = Math.floor(180 - weight * 100); alpha = weight * 0.35; } else { let weight = Math.min(1.0, (1.0 - compression) * 3.0); gray = Math.floor(230 + weight * 25); alpha = weight * 0.15; }
          ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${alpha})`; ctx.fillRect(margin + i * sliceW + y[i], centerY - h/2, (sliceW + (y[i+1]-y[i])) + 1, h);
        }
        ctx.fillStyle = "#112244"; for (let i = 0; i < N; i += 2) { const px = margin + i * waveAreaWidth / (N - 1) + y[i]; ctx.beginPath(); ctx.arc(px, centerY, 2.5, 0, Math.PI * 2); ctx.fill(); }
        ctx.fillStyle = "#007bff"; ctx.beginPath(); ctx.arc(margin + y[0], centerY, 9, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
        if(endType === "fixed"){ ctx.fillStyle = "#aaa"; ctx.fillRect(margin + waveAreaWidth, centerY - 40, 4, 80); }
      }
    }

    function loop(){ update(); draw(); requestAnimationFrame(loop); }
    updateManualText(); resetWave(); requestAnimationFrame(loop);
  </script>
</body>
</html>