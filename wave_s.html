<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <title>波シミュレーション</title>
  <style>
    /* ===== 基本設定 ===== */
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; position: fixed; background: #f0f2f5;
      font-family: -apple-system, "Helvetica Neue", "Hiragino Kaku Gothic ProN", sans-serif;
    }

    /* ===== 画面の向き警告 ===== */
    #orientation-warning {
      display: none;
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255, 255, 255, 0.98);
      z-index: 200000;
      color: #000;
      flex-direction: column; justify-content: center; align-items: center;
      text-align: center; padding: 20px; box-sizing: border-box;
    }
    
    .phone-rotate-icon {
      width: 50px;
      height: 90px;
      border: 3px solid #333;
      border-radius: 6px;
      position: relative;
      margin-bottom: 30px;
      animation: rotate-phone 2.5s infinite ease-in-out;
    }
    .phone-rotate-icon::after {
      content: "";
      position: absolute;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      border: 1.5px solid #333;
      border-radius: 50%;
    }
    @keyframes rotate-phone {
      0% { transform: rotate(0deg); }
      30%, 100% { transform: rotate(-90deg); }
    }

    #orientation-warning p {
      display: block !important; 
      font-size: 22px;
      line-height: 2.2; 
      font-weight: bold;
      margin: 0;
    }

    /* 警告画面用のルビ表示をクリアに */
    #orientation-warning ruby {
      display: inline-flex !important;
      flex-direction: column-reverse !important;
      vertical-align: bottom !important;
    }
    #orientation-warning rt {
      display: block !important;
      font-size: 0.5em !important;
      color: #555 !important;
      line-height: 1 !important;
      margin-bottom: 4px !important;
      visibility: visible !important;
      height: auto !important;
    }

    @media screen and (orientation: portrait) { #orientation-warning { display: flex; } }

    /* ===== ロード画面 ===== */
    #loading {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: white; display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 99999;
      transition: opacity 1s ease;
    }
    .logo-container { position: relative; display: inline-block; }
    #loading img { width: 180px; height: auto; display: block; }
    .loading-text { position: absolute; right: 0; bottom: -25px; font-family: sans-serif; font-size: 14px; font-weight: bold; color: #555; letter-spacing: 1px; animation: blink 1.2s infinite; }
    @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.1; } 100% { opacity: 1; } }
    #loading.fade-out { opacity: 0; pointer-events: none; }

    /* ===== 通常ルビ設定 ===== */
    ruby { display: inline-flex; flex-direction: column-reverse; vertical-align: bottom; line-height: 1; height: 2.2em; justify-content: flex-end; text-align: center; }
    rb { display: block; line-height: 1.2; }
    rt { display: block; font-size: 0.6em; line-height: 1; height: 1em; margin-bottom: 0.1em; color: #444; visibility: visible; }
    rt.dummy { color: transparent; }

    /* ===== ナビゲーション ===== */
    .nav-btn {
      text-decoration: none; color: black; background: white;
      border: 1.5px solid black; border-radius: 8px; font-size: 12px;
      font-weight: bold; width: 75px; height: 40px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .nav-btn.active { background: #e0e0ff; border-color: #0000ff; }
    #sideNav { 
      position: fixed; 
      top: calc(20px + env(safe-area-inset-top)); 
      right: 15px; 
      z-index: 9999; 
      display: flex; 
      flex-direction: column; 
      gap: 6px; 
    }

    #canvasWrapper { 
      position: absolute; 
      top: calc(30px + env(safe-area-inset-top)); 
      bottom: 110px; 
      width: 100%; 
      overflow: hidden; 
      display: flex; 
      justify-content: center; 
    }
    #canvas { display:block; background:white; border-bottom: 2px solid #ccc; touch-action: none; }

    /* ===== UIパネル ===== */
    #mainPanel {
      position: fixed; 
      bottom: calc(15px + env(safe-area-inset-bottom)); 
      left: 50%; transform: translateX(-50%);
      width: 96%; max-width: 700px; height: 75px;
      background: rgba(255,255,255,0.98); border: 2px solid black; border-radius: 20px; 
      display: flex; padding: 0 10px; gap: 8px; z-index: 100; 
      box-shadow: 0 5px 20px rgba(0,0,0,0.15); box-sizing: border-box; align-items: center;
    }

    .setting-panel {
      position: fixed; bottom: -600px; left: 50%; transform: translateX(-50%);
      width: 94%; max-width: 500px; 
      max-height: 60vh; 
      background: white; border: 2px solid black; border-radius: 20px;
      padding: 15px; z-index: 90; box-shadow: 0 -5px 25px rgba(0,0,0,0.2);
      transition: bottom 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      display: flex; flex-direction: column; gap: 12px;
      box-sizing: border-box; overflow-y: auto; 
    }
    .setting-panel.open { bottom: calc(105px + env(safe-area-inset-bottom)); }

    .ui-row { display: flex; align-items: center; gap: 10px; width: 100%; }
    .label-box { min-width: 50px; font-size: 13px; font-weight: bold; color: #444; }
    .btn-pair { display: flex; gap: 6px; flex: 1; height: 42px; }
    .ui-btn { border: 1.5px solid black; border-radius: 12px; background: white; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; box-sizing: border-box; font-weight: bold; width: 100%; height: 100%; }
    .ui-btn.active { background: #d0d0ff !important; border-color: #0000ff; }
    .main-btn { height: 55px; }

    #manualText { font-size: 13px; color: #333; text-align: center; border: 1.5px dashed #bbb; padding: 8px; border-radius: 12px; background: #fafafa; display: flex; align-items: center; justify-content: center; min-height: 2.5em; margin-top: 5px; }

    #playGuide { position: fixed; top: 45%; left: 50%; transform: translate(-50%, -50%); z-index: 2000; pointer-events: none; background: rgba(0, 0, 0, 0.7); color: white; padding: 12px 24px; border-radius: 30px; font-weight: bold; opacity: 0; transition: opacity 0.3s ease; }
    #playGuide.show { opacity: 1; }

    .slider-group { flex: 1; }
    .slider-info { display: flex; justify-content: space-between; font-weight: bold; font-size: 11px; margin-bottom: 2px; }
    .val-display { font-family: monospace; font-size: 13px; color: #0000ff; }
    input[type="range"] { width: 100%; height: 20px; cursor: pointer; }

    .modal { display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); }
    .modal-content { background: white; margin: 15% auto; padding: 20px; border: 2px solid black; border-radius: 20px; width: 85%; max-width: 500px; }
    .close { float: right; font-size: 32px; cursor: pointer; }
  </style>
</head>
<body>

  <div id="orientation-warning">
    <div class="phone-rotate-icon"></div>
    <p>
      <ruby>画<rt>が</rt>面<rt>めん</rt></ruby>を <ruby>横<rt>よこ</rt></ruby>にしてください
    </p>
  </div>

  <div id="loading">
    <div class="logo-container">
      <img src="SCOPEロゴ通常版-768x768.webp" alt="SCOPEロゴ">
      <div class="loading-text">LOADING...</div>
    </div>
  </div>

  <div id="sideNav">
    <a href="index.html" class="nav-btn">ホーム</a>
    <div class="nav-btn" onclick="showModal('howto')"><ruby><rb>使</rb><rt>つか</rt></ruby><ruby><rb>い</rb><rt class="dummy">・</rt></ruby><ruby><rb>方</rb><rt>かた</rt></ruby></div>
    <div class="nav-btn" onclick="showModal('guide')"><ruby><rb>解説</rb><rt>かいせつ</rt></ruby></div>
    <div class="nav-btn active" id="btnTheory" onclick="toggleTheoryBackground()"><ruby><rb>背景</rb><rt>はいけい</rt></ruby></div>
  </div>

  <div id="canvasWrapper" onclick="closeAllPanels()"><canvas id="canvas"></canvas></div>

  <div id="playGuide"><ruby><rb>再生</rb><rt>さいせい</rt></ruby><ruby><rb>ボタンを</rb><rt class="dummy">・</rt></ruby><ruby><rb>押</rb><rt>お</rt></ruby><ruby><rb>してね！</rb><rt class="dummy">・</rt></ruby></div>

  <div id="typePanel" class="setting-panel">
    <div class="ui-row">
      <div class="label-box"><ruby><rb>種類</rb><rt>しゅるい</rt></ruby></div>
      <div class="btn-pair">
        <div class="ui-btn active" id="btnTrans" onclick="setWaveType('trans')"><ruby><rb>横波</rb><rt>よこなみ</rt></ruby></div>
        <div class="ui-btn" id="btnLong" onclick="setWaveType('long')"><ruby><rb>縦波</rb><rt>たてなみ</rt></ruby></div>
      </div>
    </div>
  </div>

  <div id="detailPanel" class="setting-panel">
    <div class="ui-row">
      <div class="label-box"><ruby><rb>端</rb><rt>はし</rt></ruby></div>
      <div class="btn-pair">
        <div class="ui-btn active" id="btnFixedEnd" onclick="setEnd('fixed')"><ruby><rb>固定</rb><rt>こてい</rt></ruby></div>
        <div class="ui-btn" id="btnFreeEnd" onclick="setEnd('free')"><ruby><rb>自由</rb><rt>じゆう</rt></ruby></div>
      </div>
    </div>
    <div class="ui-row">
      <div class="label-box"><ruby><rb>操作</rb><rt>そうさ</rt></ruby></div>
      <div class="btn-pair">
        <div class="ui-btn active" id="btnManual" onclick="setDrive('manual')"><ruby><rb>手動</rb><rt>しゅどう</rt></ruby></div>
        <div class="ui-btn" id="btnAuto" onclick="setDrive('auto')"><ruby><rb>自動</rb><rt>じどう</rt></ruby></div>
      </div>
    </div>
    <div id="sliderArea" style="display:none; margin-top: 5px;">
      <div class="ui-row" style="gap:20px;">
        <div class="slider-group">
          <div class="slider-info"><span><ruby><rb>振幅</rb><rt>しんぷく</rt></ruby></span><span id="ampDisplay" class="val-display">40</span></div>
          <input type="range" min="10" max="60" value="40" id="ampSlider">
        </div>
        <div class="slider-group">
          <div class="slider-info"><span><ruby><rb>周波数</rb><rt>しゅうはすう</rt></ruby></span><span id="freqDisplay" class="val-display">1.00</span></div>
          <input type="range" min="0.5" max="3" step="0.01" value="1" id="freqSlider">
        </div>
      </div>
    </div>
    <div id="manualText"></div>
  </div>

  <div id="mainPanel">
    <div class="ui-btn active main-btn" id="btnPlayPause" onclick="togglePlayPause()" style="flex:2.5;"><ruby><rb>再生</rb><rt>さいせい</rt></ruby> / <ruby><rb>停止</rb><rt>ていし</rt></ruby></div>
    <div class="ui-btn main-btn" id="btnSlow" onclick="toggleSlow()" style="flex:1;">スロー</div>
    <div class="ui-btn main-btn" id="btnReset" onclick="resetWave()" style="flex:1;">リセット</div>
    <div class="ui-btn main-btn" id="btnOpenDetail" onclick="toggleDetail(); event.stopPropagation();" style="flex:1.2; background: #eee;"><ruby><rb>設定</rb><rt>せってい</rt></ruby>⚙</div>
    <div class="ui-btn main-btn" id="btnOpenType" onclick="toggleTypePanel(); event.stopPropagation();" style="flex:1.2; background: #eee;"><ruby><rb>種類</rb><rt>しゅるい</rt></ruby></div>
  </div>

  <div id="infoModal" class="modal">
    <div class="modal-content"><span class="close" onclick="closeModal()">&times;</span><h3 id="modalTitle"></h3><div id="modalBody"></div></div>
  </div>

  <script>
    let guideTimer = null;
    function triggerPlayGuide() {
      if (playing) return;
      const guide = document.getElementById("playGuide");
      guide.classList.add("show");
      if (guideTimer) clearTimeout(guideTimer);
      guideTimer = setTimeout(() => { guide.classList.remove("show"); guideTimer = null; }, 2500);
    }

    function toggleTypePanel() {
      const panel = document.getElementById("typePanel");
      const btn = document.getElementById("btnOpenType");
      document.getElementById("detailPanel").classList.remove("open");
      document.getElementById("btnOpenDetail").classList.remove("active");
      const isOpen = panel.classList.toggle("open");
      btn.classList.toggle("active", isOpen);
    }
    function toggleDetail() {
      const panel = document.getElementById("detailPanel");
      const btn = document.getElementById("btnOpenDetail");
      document.getElementById("typePanel").classList.remove("open");
      document.getElementById("btnOpenType").classList.remove("active");
      const isOpen = panel.classList.toggle("open");
      btn.classList.toggle("active", isOpen);
    }
    function closeAllPanels() {
      document.getElementById("detailPanel").classList.remove("open");
      document.getElementById("btnOpenDetail").classList.remove("active");
      document.getElementById("typePanel").classList.remove("open");
      document.getElementById("btnOpenType").classList.remove("active");
    }

    window.addEventListener("load", () => { setTimeout(() => { document.getElementById("loading").classList.add("fade-out"); }, 800); });

    function showModal(type) {
      const title = document.getElementById("modalTitle"), body = document.getElementById("modalBody");
      if(type === 'guide') { title.innerHTML = "<ruby><rb>解説</rb><rt>かいせつ</rt></ruby>"; body.innerHTML = "<ruby><rb>波</rb><rt>なみ</rt></ruby><ruby><rb>の</rb><rt class=\"dummy\">・</rt></ruby><ruby><rb>伝播</rb><rt>でんぱ</rt></ruby>シミュレーション<ruby><rb>です。</rb><rt class=\"dummy\">・</rt></ruby><br><ruby><rb>背景</rb><rt>はいけい</rt></ruby>ボタン<ruby><rb>で</rb><rt class=\"dummy\">・</rt></ruby><ruby><rb>物理</rb><rt>ぶつり</rt></ruby>イメージ<ruby><rb>を</rb><rt class=\"dummy\">・</rt></ruby><ruby><rb>表示</rb><rt>ひょうじ</rt></ruby><ruby><rb>できます。</rb><rt class=\"dummy\">・</rt></ruby>"; } 
      else if(type === 'howto') { title.innerHTML = "<ruby><rb>使</rb><rt>つか</rt></ruby><ruby><rb>い</rb><rt class=\"dummy\">・</rt></ruby><ruby><rb>方</rb><rt>かた</rt></ruby>"; body.innerHTML = "<ruby><rb>1.</rb><rt class=\"dummy\">・</rt></ruby> <b><ruby><rb>手動</rb><rt>しゅどう</rt></ruby></b>: <ruby><rb>点</rb><rt>てん</rt></ruby><ruby><rb>を</rb><rt class=\"dummy\">・</rt></ruby>ドラッグ<ruby><rb>して</rb><rt class=\"dummy\">・</rt></ruby><ruby><rb>波</rb><rt>なみ</rt></ruby><ruby><rb>を</rb><rt class=\"dummy\">・</rt></ruby><ruby><rb>作</rb><rt>つく</rt></ruby><ruby><rb>ります。</rb><rt class=\"dummy\">・</rt></ruby><br><ruby><rb>2.</rb><rt class=\"dummy\">・</rt></ruby> <b><ruby><rb>自動</rb><rt>じどう</rt></ruby></b>: サイン<ruby><rb>波</rb><rt>なみ</rt></ruby><ruby><rb>を</rb><rt class=\"dummy\">・</rt></ruby><ruby><rb>発生</rb><rt>はいせい</rt></ruby><ruby><rb>させます。</rb><rt class=\"dummy\">・</rt></ruby><br><ruby><rb>3.</rb><rt class=\"dummy\">・</rt></ruby> <b><ruby><rb>端</rb><rt>はし</rt></ruby></b>: <ruby><rb>反射</rb><rt>はんしゃ</rt></ruby><ruby><rb>の</rb><rt class=\"dummy\">・</rt></ruby><ruby><rb>違</rb><rt>ちが</rt></ruby><ruby><rb>いを</rb><rt class=\"dummy\">・</rt></ruby><ruby><rb>観察</rb><rt>かんさつ</rt></ruby><ruby><rb>できます。</rb><rt class=\"dummy\">・</rt></ruby>"; }
      document.getElementById("infoModal").style.display = "block";
    }
    function closeModal() { document.getElementById("infoModal").style.display = "none"; }

    function updateManualText() {
      const target = document.getElementById("manualText");
      const color = (waveType === "trans") ? {t:"赤", r:"あか"} : {t:"青", r:"あお"};
      target.innerHTML = `<ruby><rb>${color.t}</rb><rt>${color.r}</rt></ruby><ruby><rb>い</rb><rt class="dummy">・</rt></ruby><ruby><rb>点</rb><rt>てん</rt></ruby><ruby><rb>を</rb><rt class="dummy">・</rt></ruby><ruby><rb>動</rb><rt>うご</rt></ruby><ruby><rb>かして</rb><rt class="dummy">・</rt></ruby><ruby><rb>波</rb><rt>なみ</rt></ruby><ruby><rb>を</rb><rt class="dummy">・</rt></ruby><ruby><rb>描</rb><rt>か</rt></ruby><ruby><rb>こう！</rb><rt class="dummy">・</rt></ruby>`;
    }

    const imgSky = new Image(); imgSky.src = "sky.png";
    const imgSea = new Image(); imgSea.src = "sea.png";
    const imgMusical = new Image(); imgMusical.src = "musical.png";
    const imgPlay = new Image(); imgPlay.src = "play.png";
    const imgNote = new Image(); imgNote.src = "note.png";

    const SKY_IMG_HEIGHT = 500, SEA_IMG_HEIGHT = 500, MUSICAL_IMG_HEIGHT = 400, BG_X_OFFSET = 15;
    let showBackground = true, driveType = "manual", playing = true;
    const canvas = document.getElementById("canvas"), ctx = canvas.getContext("2d");
    const ampSlider = document.getElementById("ampSlider"), freqSlider = document.getElementById("freqSlider");
    const ampDisplay = document.getElementById("ampDisplay"), freqDisplay = document.getElementById("freqDisplay");

    let waveType = "trans", endType = "fixed";
    let margin = 70, N = 240;
    let y = new Array(N).fill(0), v = new Array(N).fill(0), dragging = false;
    const damping = 0.998, c = 2.0;

    let currentSpeedScale = 1.0, theta = 0, currentAmp = 40, currentFreq = 1.0, currentOmega = 2*Math.PI*currentFreq;
    let pendingAmp = 40, pendingFreq = 1.0, hasPending = false;
    let speedRamp = { active:false, start:1.0, end:1.0, elapsed:0, duration:0.35 };
    let ampRamp = { active:false, startAmp:40, endAmp:40, progress:0, durationSec:1 };
    let accel = { active:false, targetOmega:currentOmega, accelValue:0, timeLeft:0 };
    let driverTarget = 0, manualInertiaVel = 0, manualRawTarget = 0, manualFilteredTarget = 0;
    const manualTau = 0.015;
    let noteFade = 0.0;

    function lerp(a,b,t){ return a + (b-a)*t; }
    function smoothstep(t){ return t<=0?0:t>=1?1:t*t*(3-2*t); }
    
    function getLimit() {
      return Math.max(10, Math.min(60, (canvas.height / 2) - 20));
    }

    function resizeCanvas(){ 
        const wrapper = document.getElementById("canvasWrapper");
        if (!wrapper) return;
        canvas.width = wrapper.clientWidth; 
        canvas.height = wrapper.clientHeight; 
    }
    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("orientationchange", () => { setTimeout(resizeCanvas, 300); });
    resizeCanvas();

    function resetWave(){
      y.fill(0); v.fill(0); theta = 0; currentAmp = pendingAmp = parseFloat(ampSlider.value);
      currentFreq = pendingFreq = parseFloat(freqSlider.value); currentOmega = 2*Math.PI*currentFreq;
      ampRamp.active = false; hasPending = false; accel.active = false;
      driverTarget = 0; manualInertiaVel = 0; manualRawTarget = 0; manualFilteredTarget = 0; noteFade = 0;
    }

    function toggleTheoryBackground() { showBackground = !showBackground; document.getElementById("btnTheory").classList.toggle("active", showBackground); }
    
    function setWaveType(type){ 
      waveType = type; resetWave(); 
      document.getElementById("btnTrans").classList.toggle("active", type==="trans"); 
      document.getElementById("btnLong").classList.toggle("active", type==="long"); 
      updateManualText(); 
      setTimeout(closeAllPanels, 300);
    }
    
    function setDrive(type){ 
      if(type === "manual" && driveType === "auto") manualInertiaVel = currentAmp * currentOmega * Math.cos(theta); 
      else manualInertiaVel = 0; 
      manualRawTarget = y[0]; manualFilteredTarget = y[0]; driverTarget = y[0]; driveType = type; 
      document.getElementById("btnManual").classList.toggle("active", type==="manual"); 
      document.getElementById("btnAuto").classList.toggle("active", type==="auto"); 
      const sliderArea = document.getElementById("sliderArea"), manualText = document.getElementById("manualText");
      if(type === "manual") { sliderArea.style.display = "none"; manualText.style.display = "flex"; } 
      else { sliderArea.style.display = "block"; manualText.style.display = "none"; }
      updateManualText(); 
    }
    function setEnd(type){ endType = type; document.getElementById("btnFixedEnd").classList.toggle("active", type==="fixed"); document.getElementById("btnFreeEnd").classList.toggle("active", type==="free"); }

    function handlePointer(e) {
      if(driveType !== "manual") return;
      if(!playing) triggerPlayGuide();
      const rect = canvas.getBoundingClientRect();
      const clientX = (e.touches ? e.touches[0].clientX : e.clientX), clientY = (e.touches ? e.touches[0].clientY : e.clientY);
      const cx = clientX - rect.left, cy = clientY - rect.top;
      const limit = getLimit();
      if (waveType === "trans") { manualRawTarget = Math.max(-limit, Math.min(limit, cy - canvas.height/2)); }
      else { manualRawTarget = Math.max(-limit, Math.min(limit, cx - margin)); }
    }

    canvas.addEventListener("mousedown", e => { dragging = true; handlePointer(e); manualFilteredTarget = manualRawTarget; manualInertiaVel = 0; });
    window.addEventListener("mousemove", e => { if(dragging) handlePointer(e); });
    window.addEventListener("mouseup", () => dragging = false);
    canvas.addEventListener("touchstart", e => { e.preventDefault(); dragging = true; handlePointer(e); manualFilteredTarget = manualRawTarget; manualInertiaVel = 0; }, {passive:false});
    canvas.addEventListener("touchmove", e => { e.preventDefault(); if(dragging) handlePointer(e); }, {passive:false});
    canvas.addEventListener("touchend", () => dragging = false);

    ampSlider.oninput = ()=>{ ampDisplay.textContent = ampSlider.value; pendingAmp = parseFloat(ampSlider.value); hasPending = true; };
    freqSlider.oninput = ()=>{ freqDisplay.textContent = Number(freqSlider.value).toFixed(2); pendingFreq = parseFloat(freqSlider.value); hasPending = true; };
    
    function togglePlayPause(){ playing = !playing; document.getElementById("btnPlayPause").classList.toggle("active", playing); if(playing) { document.getElementById("playGuide").classList.remove("show"); if(guideTimer) { clearTimeout(guideTimer); guideTimer = null; } } }
    function toggleSlow(){ let isSlow = (speedRamp.active ? speedRamp.end < 1.0 : currentSpeedScale < 1.0); document.getElementById("btnSlow").classList.toggle("active", !isSlow); speedRamp = { active:true, start:currentSpeedScale, end:isSlow?1.0:0.25, elapsed:0, duration:0.35 }; }

    function update(){
      if(!playing) return;
      const frameBaseSec = 0.016;
      if(speedRamp.active){ speedRamp.elapsed += frameBaseSec; let tr = Math.min(1, speedRamp.elapsed / speedRamp.duration); currentSpeedScale = lerp(speedRamp.start, speedRamp.end, smoothstep(tr)); if(tr >= 1){ currentSpeedScale = speedRamp.end; speedRamp.active = false; } }
      const deltaRealSec = frameBaseSec * currentSpeedScale;
      if(accel.active){ if(deltaRealSec >= accel.timeLeft){ currentOmega = accel.targetOmega; accel.active = false; } else { currentOmega += accel.accelValue * deltaRealSec; accel.timeLeft -= deltaRealSec; } }
      theta += currentOmega * deltaRealSec;
      if(hasPending){ const newOmega = 2*Math.PI*pendingFreq; const accelDuration = 1 / pendingFreq; accel = { active:true, targetOmega:newOmega, timeLeft:accelDuration, accelValue:(newOmega - currentOmega) / accelDuration }; ampRamp = { active:true, startAmp:40, endAmp:pendingAmp, progress:0, durationSec:accelDuration }; hasPending = false; }
      if(ampRamp.active){ ampRamp.progress += deltaRealSec / ampRamp.durationSec; currentAmp = lerp(ampRamp.startAmp, ampRamp.endAmp, smoothstep(Math.min(1, ampRamp.progress))); if(ampRamp.progress >= 1) ampRamp.active = false; }
      
      if(driveType === "auto") {
        const limit = getLimit();
        let target = (currentAmp / 60) * limit * Math.sin(theta);
        driverTarget += (target - driverTarget) * (1 - Math.exp(-deltaRealSec / 0.04));
      }
      else if(dragging){ manualFilteredTarget += (manualRawTarget - manualFilteredTarget) * (1 - Math.exp(-deltaRealSec / manualTau)); driverTarget = manualFilteredTarget; }
      else { if (Math.abs(driverTarget) > 0.01 || Math.abs(manualInertiaVel) > 0.1) { manualInertiaVel += (-150 * driverTarget) * deltaRealSec; manualInertiaVel *= Math.pow(0.45, deltaRealSec * 60); driverTarget += manualInertiaVel * deltaRealSec; } else { driverTarget = 0; } }
      y[0] = driverTarget;
      const phDt = 0.5 * currentSpeedScale;
      for(let i=1;i<N-1;i++){ v[i] += c*c*(y[i+1] + y[i-1] - 2*y[i]) * phDt; v[i] *= damping; }
      for(let i=1;i<N-1;i++) y[i] += v[i] * phDt;
      if(endType === "fixed"){ y[N-1] = 0; v[N-1] = 0; } else { y[N-1] = y[N-2]; v[N-1] = v[N-2]; }
      const isMoving = Math.abs(y[0]) > 0.5 || (driveType === "auto" && playing);
      if (isMoving) { noteFade = Math.min(1.0, noteFade + 0.05); } else { noteFade = Math.max(0.0, noteFade - 0.03); }
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const waveAreaWidth = canvas.width - (margin * 2), centerY = canvas.height / 2;
      const limit = getLimit();

      if (waveType === "trans") {
        if (showBackground) {
          const bgX = margin + BG_X_OFFSET, bgW = waveAreaWidth - BG_X_OFFSET;
          ctx.save(); ctx.beginPath(); ctx.moveTo(bgX, canvas.height);
          for(let i=0; i<N; i++){ let px = margin + i * waveAreaWidth / (N-1); if(px >= bgX) ctx.lineTo(px, centerY + y[i]); }
          ctx.lineTo(margin + waveAreaWidth, canvas.height); ctx.clip();
          ctx.drawImage(imgSea, bgX, (centerY - SEA_IMG_HEIGHT/2) -50, bgW, SEA_IMG_HEIGHT); ctx.restore();
          ctx.save(); ctx.beginPath(); ctx.moveTo(bgX, 0);
          for(let i=0; i<N; i++){ let px = margin + i * waveAreaWidth / (N-1); if(px >= bgX) ctx.lineTo(px, centerY + y[i]); }
          ctx.lineTo(margin + waveAreaWidth, 0); ctx.clip();
          ctx.drawImage(imgSky, bgX, (centerY - SKY_IMG_HEIGHT/2) +25, bgW, SKY_IMG_HEIGHT); ctx.restore();
        }
        ctx.strokeStyle = "#ccc"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(margin, centerY - limit); ctx.lineTo(margin, centerY + limit); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(margin - 10, centerY - limit); ctx.lineTo(margin + 10, centerY - limit); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(margin - 10, centerY + limit); ctx.lineTo(margin + 10, centerY + limit); ctx.stroke();
        ctx.strokeStyle = "black"; ctx.lineWidth = 2; ctx.beginPath(); for(let i=0;i<N;i++) ctx.lineTo(margin + i*waveAreaWidth/(N-1), centerY + y[i]); ctx.stroke();
        ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(margin, centerY + y[0], 6, 0, Math.PI*2); ctx.fill();
      } else {
        const h = 24, sliceW = waveAreaWidth / (N - 1);
        if (showBackground) {
          ctx.save(); ctx.globalAlpha = 0.5;
          const safeZone = limit + 50; 
          const targetX = margin + safeZone; 
          const targetW = waveAreaWidth - safeZone; 
          const targetY = centerY - MUSICAL_IMG_HEIGHT / 2;
          if (targetW > 50) {
            ctx.beginPath(); ctx.rect(targetX, targetY, targetW, MUSICAL_IMG_HEIGHT); ctx.clip();
            const imgAspect = (imgMusical.width || 100) / (imgMusical.height || 100);
            let dW = targetW, dH = targetW / imgAspect;
            if (dH < MUSICAL_IMG_HEIGHT) { dH = MUSICAL_IMG_HEIGHT; dW = dH * imgAspect; }
            ctx.drawImage(imgMusical, targetX + (targetW - dW)/2, targetY + (MUSICAL_IMG_HEIGHT - dH)/2, dW, dH);
          }
          ctx.restore();
          ctx.drawImage(imgPlay, margin + safeZone + 20, centerY + 40, 150, 150);
          if (noteFade > 0) { ctx.save(); ctx.globalAlpha = (0.55 + 0.15 * Math.sin(Date.now() / 250)) * noteFade; ctx.drawImage(imgNote, margin + safeZone + 180, centerY + 50, 130, 130); ctx.restore(); }
        }
        ctx.strokeStyle = "#ccc"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(margin - limit, centerY - 20); ctx.lineTo(margin - limit, centerY + 20); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(margin + limit, centerY - 20); ctx.lineTo(margin + limit, centerY + 20); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(margin - limit, centerY); ctx.lineTo(margin + limit, centerY); ctx.stroke();
        for (let i = 0; i < N - 1; i++) {
          const dx = ((i + 1) * sliceW + y[i + 1]) - (i * sliceW + y[i]), compression = sliceW / dx;
          let gray, alpha;
          if (compression >= 1.0) { let weight = Math.min(1.0, (compression - 1.0) * 3.0); gray = Math.floor(180 - weight * 100); alpha = weight * 0.35; } else { let weight = Math.min(1.0, (1.0 - compression) * 3.0); gray = Math.floor(230 + weight * 25); alpha = weight * 0.15; }
          ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${alpha})`;
          ctx.fillRect(margin + i * sliceW + y[i], centerY - h/2, (sliceW + (y[i+1]-y[i])) + 1, h);
        }
        ctx.fillStyle = "#112244"; for (let i = 0; i < N; i += 2) { const px = margin + i * waveAreaWidth / (N - 1) + y[i]; ctx.beginPath(); ctx.arc(px, centerY, 2.5, 0, Math.PI * 2); ctx.fill(); }
        ctx.fillStyle = "#007bff"; ctx.beginPath(); ctx.arc(margin + y[0], centerY, 9, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
        if(endType === "fixed"){ ctx.fillStyle = "#aaa"; ctx.fillRect(margin + waveAreaWidth, centerY - 40, 4, 80); }
      }
    }

    function loop(){ update(); draw(); requestAnimationFrame(loop); }
    updateManualText(); resetWave(); requestAnimationFrame(loop);
  </script>
</body>
</html>