<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>波シミュレーション</title>
  <style>
    /* ===== 基本設定 ===== */
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; position: fixed; background: #f0f2f5;
      font-family: -apple-system, "Helvetica Neue", "Hiragino Kaku Gothic ProN", sans-serif;
    }

    /* ===== ロード画面 ===== */
    #loading {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: white; display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 99999;
      transition: opacity 1s ease;
    }
    .logo-container { position: relative; display: inline-block; }
    #loading img { width: 180px; height: auto; display: block; }
    .loading-text {
      position: absolute; right: 0; bottom: -25px;
      font-family: sans-serif; font-size: 14px; font-weight: bold; color: #555;
      letter-spacing: 1px; animation: blink 1.2s infinite;
    }
    @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.1; } 100% { opacity: 1; } }
    #loading.fade-out { opacity: 0; pointer-events: none; }

    /* ===== ルビ設定 ===== */
    ruby {
      display: inline-flex; flex-direction: column-reverse;
      vertical-align: bottom; line-height: 1; height: 2.2em;
      justify-content: flex-end; text-align: center;
    }
    rb { display: block; line-height: 1.2; }
    rt {
      display: block; font-size: 0.6em; line-height: 1;
      height: 1em; margin-bottom: 0.1em; color: #444; visibility: visible;
    }

    /* ===== ナビゲーション ===== */
    .nav-btn {
      text-decoration: none; color: black; background: white;
      border: 1.5px solid black; border-radius: 8px; font-size: 12px;
      font-weight: bold; width: 75px; height: 42px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    #sideNav { position: fixed; top: 10px; right: 10px; z-index: 9999; display: flex; flex-direction: column; gap: 6px; }

    #typeNav { 
      position: fixed; top: 15px; left: 50%; transform: translateX(-50%); 
      z-index: 10000; display: flex; flex-direction: row; gap: 15px; 
      background: rgba(255,255,255,0.8); padding: 8px 15px; border-radius: 15px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }

    #canvasWrapper { position: absolute; top: 0; bottom: 200px; width: 100%; overflow: hidden; display: flex; justify-content: center; }
    #canvas { display:block; background:white; border-bottom: 2px solid #ccc; touch-action: none; }

    /* ===== 下部パネル ===== */
    #mainPanel {
      position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
      width: 98%; max-width: 1000px; height: 185px;
      background: rgba(255,255,255,0.98); border: 2px solid black; border-radius: 20px; 
      display: flex; flex-direction: column;
      padding: 12px; z-index: 50; 
      box-shadow: 0 5px 20px rgba(0,0,0,0.15); box-sizing: border-box;
    }

    .row-main {
      display: flex; gap: 10px; height: 52px; margin-bottom: 10px;
      padding-bottom: 10px; border-bottom: 1.5px solid black;
    }
    .row-main .ui-btn { flex: 1; height: 100%; font-size: 14px; }
    #btnReset { background-color: #e0e0e0; }

    .row-sub { display: flex; flex: 1; gap: 0; align-items: stretch; }
    .col { display: flex; flex-direction: column; gap: 5px; justify-content: center; }
    .col-left { flex: 1.2; }
    .col-right { flex: 6; display: flex; flex-direction: row; gap: 20px; align-items: center; }
    
    .divider { width: 1.5px; background-color: black; margin: 0 15px; }

    .ui-btn { 
      border: 1.5px solid black; border-radius: 8px; background: white; 
      cursor: pointer; font-size: 12px; display: flex; align-items: center; 
      justify-content: center; font-weight: bold; width: 100%; height: 32px;
    }
    .ui-btn.active { background: #d0d0ff !important; border-color: #0000ff; }

    .controls-stack { display: flex; flex-direction: column; gap: 10px; flex: 1; }
    .setting-block { display: flex; align-items: center; gap: 10px; }
    .label-text { font-size: 12px; font-weight: bold; min-width: 35px; text-align: left; }
    .btn-pair { display: flex; gap: 4px; flex: 1; }
    .btn-pair .ui-btn { height: 36px; flex: 1; }

    .right-content-area { width: 100%; max-width: 280px; display: flex; flex-direction: column; justify-content: center; height: 80px; }
    .slider-stack { display: flex; flex-direction: column; gap: 10px; width: 100%; }
    .slider-group { width: 100%; }
    .slider-info { display: flex; justify-content: space-between; font-weight: bold; font-size: 10px; margin-bottom: 2px; }
    .val-display { font-family: monospace; font-size: 12px; color: #0000ff; }
    input[type="range"] { width: 100%; height: 20px; cursor: pointer; margin: 0; }

    #manualText { 
      font-size: 12px; color: #666; text-align: center; border: 1.5px dashed #ccc; 
      border-radius: 10px; background: #fff; flex: 1; height: 80px;
      display: flex; align-items: center; justify-content: center;
    }

    #playGuide {
      position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%);
      z-index: 2000; pointer-events: none; background: rgba(0, 0, 0, 0.7);
      color: white; padding: 12px 24px; border-radius: 30px; font-weight: bold;
      opacity: 0; transition: opacity 0.3s ease;
    }
    #playGuide.show { opacity: 1; }

    .modal { display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); }
    .modal-content { background: white; margin: 15% auto; padding: 20px; border: 2px solid black; border-radius: 20px; width: 85%; max-width: 500px; }
    .close { float: right; font-size: 32px; cursor: pointer; }
  </style>
</head>
<body>

  <div id="loading">
    <div class="logo-container">
      <img src="SCOPEロゴ通常版-768x768.webp" alt="SCOPEロゴ">
      <div class="loading-text">LOADING...</div>
    </div>
  </div>

  <div id="typeNav">
    <div class="ui-btn active" id="btnTrans" onclick="setWaveType('trans')" style="width: 100px;"><ruby><rb>横波</rb><rt>よこなみ</rt></ruby></div>
    <div class="ui-btn" id="btnLong" onclick="setWaveType('long')" style="width: 100px;"><ruby><rb>縦波</rb><rt>たてなみ</rt></ruby></div>
  </div>

  <div id="sideNav">
    <a href="index.html" class="nav-btn">ホーム</a>
    <div class="nav-btn" onclick="showModal('howto')"><ruby><rb>使</rb><rt>つか</rt></ruby>い<ruby><rb>方</rb><rt>かた</rt></ruby></div>
  </div>

  <div id="canvasWrapper" onclick="closeAllPanels()"><canvas id="canvas"></canvas></div>

  <div id="playGuide">
    <ruby><rb>再生</rb><rt>さいせい</rt></ruby>ボタンを<ruby><rb>押</rb><rt>お</rt></ruby>してね！
  </div>

  <div id="mainPanel">
    <div class="row-main">
      <div class="ui-btn active" id="btnPlayPause" onclick="togglePlayPause()"><ruby><rb>再生</rb><rt>さいせい</rt></ruby> / <ruby><rb>停止</rb><rt>ていし</rt></ruby></div>
      <div class="ui-btn" id="btnSlow" onclick="toggleSlow()">スロー</div>
      <div class="ui-btn" id="btnReset" onclick="resetWave()">リセット</div>
    </div>

    <div class="row-sub">
      <div class="col col-left">
        <div class="ui-btn" onclick="showModal('guide')"><ruby><rb>解説</rb><rt>かいせつ</rt></ruby></div>
        <div class="ui-btn active" id="btnTheory" onclick="toggleTheoryBackground()"><ruby><rb>背景</rb><rt>はいけい</rt></ruby></div>
      </div>

      <div class="divider"></div>

      <div class="col col-right">
        <div class="controls-stack">
          <div class="setting-block">
            <span class="label-text"><ruby><rb>操作</rb><rt>そうさ</rt></ruby></span>
            <div class="btn-pair">
              <div class="ui-btn active" id="btnManual" onclick="setDrive('manual')"><ruby><rb>手動</rb><rt>しゅどう</rt></ruby></div>
              <div class="ui-btn" id="btnAuto" onclick="setDrive('auto')"><ruby><rb>自動</rb><rt>じどう</rt></ruby></div>
            </div>
          </div>
          <div class="setting-block">
            <span class="label-text"><ruby><rb>端</rb><rt>はし</rt></ruby></span>
            <div class="btn-pair">
              <div class="ui-btn active" id="btnFixedEnd" onclick="setEnd('fixed')"><ruby><rb>固定</rb><rt>こてい</rt></ruby></div>
              <div class="ui-btn" id="btnFreeEnd" onclick="setEnd('free')"><ruby><rb>自由</rb><rt>じゆう</rt></ruby></div>
            </div>
          </div>
        </div>

        <div class="right-content-area">
          <div id="manualText"></div>
          <div id="sliderArea" class="slider-stack" style="display:none;">
            <div class="slider-group">
              <div class="slider-info"><span><ruby><rb>振幅</rb><rt>しんぷく</rt></ruby></span><span id="ampDisplay" class="val-display">40</span></div>
              <input type="range" min="10" max="60" value="40" id="ampSlider">
            </div>
            <div class="slider-group">
              <div class="slider-info"><span><ruby><rb>周波数</rb><rt>しゅうはすう</rt></ruby></span><span id="freqDisplay" class="val-display">1.00</span></div>
              <input type="range" min="0.5" max="3" step="0.01" value="1" id="freqSlider">
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="infoModal" class="modal">
    <div class="modal-content"><span class="close" onclick="closeModal()">&times;</span><h3 id="modalTitle"></h3><div id="modalBody"></div></div>
  </div>

  <script>
    let guideTimer = null;
    function triggerPlayGuide() { if (playing) return; const guide = document.getElementById("playGuide"); guide.classList.add("show"); if (guideTimer) clearTimeout(guideTimer); guideTimer = setTimeout(() => { guide.classList.remove("show"); guideTimer = null; }, 2500); }
    function closeAllPanels() {}
    window.addEventListener("load", () => { setTimeout(() => { document.getElementById("loading").classList.add("fade-out"); }, 800); });

    function showModal(type) {
      const title = document.getElementById("modalTitle"), body = document.getElementById("modalBody");
      if(type === 'guide') { title.innerHTML = "解説"; body.innerHTML = "波の伝播シミュレーションです。"; } 
      else if(type === 'howto') { title.innerHTML = "使い方"; body.innerHTML = "1. <b>手動</b>: 点をドラッグ<br>2. <b>自動</b>: スライダーで調節"; }
      document.getElementById("infoModal").style.display = "block";
    }
    function closeModal() { document.getElementById("infoModal").style.display = "none"; }
    
    function updateManualText() {
      const target = document.getElementById("manualText");
      const color = (waveType === "trans") ? {t:"赤", r:"あか"} : {t:"青", r:"あお"};
      target.innerHTML = `<ruby><rb>${color.t}</rb><rt>${color.r}</rt></ruby>い<ruby><rb>点</rb><rt>てん</rt></ruby>を<ruby><rb>動</rb><rt>うご</rt></ruby>かして<ruby><rb>波</rb><rt>なみ</rt></ruby>を<ruby><rb>作</rb><rt>つく</rt></ruby>ろう！`;
    }

    const imgSky = new Image(); imgSky.src = "sky.png";
    const imgSea = new Image(); imgSea.src = "sea.png";
    const imgMusical = new Image(); imgMusical.src = "musical.png";
    const imgPlay = new Image(); imgPlay.src = "play.png";
    const imgNote = new Image(); imgNote.src = "note.png";

    const SKY_IMG_HEIGHT = 500, SEA_IMG_HEIGHT = 500, MUSICAL_IMG_HEIGHT = 400, BG_X_OFFSET = 15;
    let showBackground = true, driveType = "manual", playing = true;
    const canvas = document.getElementById("canvas"), ctx = canvas.getContext("2d");
    const ampSlider = document.getElementById("ampSlider"), freqSlider = document.getElementById("freqSlider");
    const ampDisplay = document.getElementById("ampDisplay"), freqDisplay = document.getElementById("freqDisplay");

    let waveType = "trans", endType = "fixed", margin = 70, N = 240, y = new Array(N).fill(0), v = new Array(N).fill(0), dragging = false;
    const damping = 0.998, c = 2.0;

    let currentSpeedScale = 1.0, theta = 0, currentAmp = 40, currentFreq = 1.0, currentOmega = 2*Math.PI*currentFreq;
    let pendingAmp = 40, pendingFreq = 1.0, hasPending = false;
    let speedRamp = { active:false, start:1.0, end:1.0, elapsed:0, duration:0.35 };
    let ampRamp = { active:false, startAmp:40, endAmp:40, progress:0, durationSec:1 };
    let accel = { active:false, targetOmega:currentOmega, accelValue:0, timeLeft:0 };
    let driverTarget = 0, manualInertiaVel = 0, manualRawTarget = 0, manualFilteredTarget = 0;
    const manualTau = 0.015;
    let noteFade = 0.0;

    function lerp(a,b,t){ return a + (b-a)*t; }
    function smoothstep(t){ return t<=0?0:t>=1?1:t*t*(3-2*t); }
    function resizeCanvas(){ const wrapper = document.getElementById("canvasWrapper"); canvas.width = wrapper.clientWidth; canvas.height = wrapper.clientHeight; }
    window.addEventListener("resize", resizeCanvas); resizeCanvas();

    function resetWave(){ y.fill(0); v.fill(0); theta = 0; currentAmp = pendingAmp = parseFloat(ampSlider.value); currentFreq = pendingFreq = parseFloat(freqSlider.value); currentOmega = 2*Math.PI*currentFreq; ampRamp.active = false; hasPending = false; accel.active = false; driverTarget = 0; manualInertiaVel = 0; manualRawTarget = 0; manualFilteredTarget = 0; noteFade = 0; }
    function toggleTheoryBackground() { showBackground = !showBackground; document.getElementById("btnTheory").classList.toggle("active", showBackground); }
    function setWaveType(type){ waveType = type; resetWave(); document.getElementById("btnTrans").classList.toggle("active", type==="trans"); document.getElementById("btnLong").classList.toggle("active", type==="long"); updateManualText(); }
    
    function setDrive(type){ 
      if(type === "manual" && driveType === "auto") manualInertiaVel = currentAmp * currentOmega * Math.cos(theta);
      else manualInertiaVel = 0;
      manualRawTarget = y[0]; manualFilteredTarget = y[0]; driverTarget = y[0]; driveType = type; 
      document.getElementById("btnManual").classList.toggle("active", type==="manual"); document.getElementById("btnAuto").classList.toggle("active", type==="auto"); 
      const sliderArea = document.getElementById("sliderArea"), manualText = document.getElementById("manualText");
      if(type === "manual") { sliderArea.style.display = "none"; manualText.style.display = "flex"; } else { sliderArea.style.display = "flex"; manualText.style.display = "none"; }
      updateManualText();
    }
    function setEnd(type){ endType = type; document.getElementById("btnFixedEnd").classList.toggle("active", type==="fixed"); document.getElementById("btnFreeEnd").classList.toggle("active", type==="free"); }

    function handlePointer(e) { if(driveType !== "manual") return; if(!playing) triggerPlayGuide(); const rect = canvas.getBoundingClientRect(); const clientX = (e.touches ? e.touches[0].clientX : e.clientX); const clientY = (e.touches ? e.touches[0].clientY : e.clientY); const cx = clientX - rect.left, cy = clientY - rect.top; const limit = 60; if (waveType === "trans") { manualRawTarget = Math.max(-limit, Math.min(limit, cy - canvas.height/2)); } else { manualRawTarget = Math.max(-limit, Math.min(limit, cx - margin)); } }

    canvas.addEventListener("mousedown", e => { dragging = true; handlePointer(e); manualFilteredTarget = manualRawTarget; manualInertiaVel = 0; });
    window.addEventListener("mousemove", e => { if(dragging) handlePointer(e); });
    window.addEventListener("mouseup", () => dragging = false);
    canvas.addEventListener("touchstart", e => { e.preventDefault(); dragging = true; handlePointer(e); manualFilteredTarget = manualRawTarget; manualInertiaVel = 0; }, {passive:false});
    canvas.addEventListener("touchmove", e => { e.preventDefault(); if(dragging) handlePointer(e); }, {passive:false});
    canvas.addEventListener("touchend", () => dragging = false);

    ampSlider.oninput = ()=>{ ampDisplay.textContent = ampSlider.value; pendingAmp = parseFloat(ampSlider.value); hasPending = true; };
    freqSlider.oninput = ()=>{ freqDisplay.textContent = Number(freqSlider.value).toFixed(2); pendingFreq = parseFloat(freqSlider.value); hasPending = true; };
    function togglePlayPause(){ playing = !playing; document.getElementById("btnPlayPause").classList.toggle("active", playing); if(playing) document.getElementById("playGuide").classList.remove("show"); }
    function toggleSlow(){ let isSlow = (speedRamp.active ? speedRamp.end < 1.0 : currentSpeedScale < 1.0); document.getElementById("btnSlow").classList.toggle("active", !isSlow); speedRamp = { active:true, start:currentSpeedScale, end:isSlow?1.0:0.25, elapsed:0, duration:0.35 }; }

    function update(){
      if(!playing) return;
      const frameBaseSec = 0.016;
      if(speedRamp.active){ speedRamp.elapsed += frameBaseSec; let tr = Math.min(1, speedRamp.elapsed / speedRamp.duration); currentSpeedScale = lerp(speedRamp.start, speedRamp.end, smoothstep(tr)); if(tr >= 1){ currentSpeedScale = speedRamp.end; speedRamp.active = false; } }
      const deltaRealSec = frameBaseSec * currentSpeedScale;
      if(accel.active){ if(deltaRealSec >= accel.timeLeft){ currentOmega = accel.targetOmega; accel.active = false; } else { currentOmega += accel.accelValue * deltaRealSec; accel.timeLeft -= deltaRealSec; } }
      theta += currentOmega * deltaRealSec;
      if(hasPending){ const newOmega = 2*Math.PI*pendingFreq; const accelDuration = 1/pendingFreq; accel = { active:true, targetOmega:newOmega, timeLeft:accelDuration, accelValue:(newOmega - currentOmega) / accelDuration }; ampRamp = { active:true, startAmp:currentAmp, endAmp:pendingAmp, progress:0, durationSec:accelDuration }; hasPending = false; }
      if(ampRamp.active){ ampRamp.progress += deltaRealSec / ampRamp.durationSec; currentAmp = lerp(ampRamp.startAmp, ampRamp.endAmp, smoothstep(Math.min(1, ampRamp.progress))); if(ampRamp.progress >= 1) ampRamp.active = false; }
      if(driveType === "auto") driverTarget += (currentAmp * Math.sin(theta) - driverTarget) * (1 - Math.exp(-deltaRealSec / 0.04));
      else if(dragging){ manualFilteredTarget += (manualRawTarget - manualFilteredTarget) * (1 - Math.exp(-deltaRealSec / manualTau)); driverTarget = manualFilteredTarget; }
      else { if (Math.abs(driverTarget) > 0.01 || Math.abs(manualInertiaVel) > 0.1) { manualInertiaVel += (-150 * driverTarget) * deltaRealSec; manualInertiaVel *= Math.pow(0.45, deltaRealSec * 60); driverTarget += manualInertiaVel * deltaRealSec; } else { driverTarget = 0; } }
      y[0] = driverTarget;
      const phDt = 0.5 * currentSpeedScale;
      for(let i=1;i<N-1;i++){ v[i] += c*c*(y[i+1] + y[i-1] - 2*y[i]) * phDt; v[i] *= damping; }
      for(let i=1;i<N-1;i++) y[i] += v[i] * phDt;
      if(endType === "fixed"){ y[N-1] = 0; v[N-1] = 0; } else { y[N-1] = y[N-2]; v[N-1] = v[N-2]; }
      const isMoving = Math.abs(y[0]) > 0.5 || (driveType === "auto" && playing);
      if (isMoving) { noteFade = Math.min(1.0, noteFade + 0.05); } else { noteFade = Math.max(0.0, noteFade - 0.03); }
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const waveAreaWidth = canvas.width - (margin * 2), centerY = canvas.height / 2;
      const limit = 60;
      if (waveType === "trans") {
        if (showBackground) {
          const bgX = margin + BG_X_OFFSET, bgW = waveAreaWidth - BG_X_OFFSET;
          ctx.save(); ctx.beginPath(); ctx.moveTo(bgX, canvas.height);
          for(let i=0; i<N; i++){ let px = margin + i * waveAreaWidth / (N-1); if(px >= bgX) ctx.lineTo(px, centerY + y[i]); }
          ctx.lineTo(margin + waveAreaWidth, canvas.height); ctx.clip();
          ctx.drawImage(imgSea, bgX, (centerY - SEA_IMG_HEIGHT/2) -50, bgW, SEA_IMG_HEIGHT); ctx.restore();
          ctx.save(); ctx.beginPath(); ctx.moveTo(bgX, 0);
          for(let i=0; i<N; i++){ let px = margin + i * waveAreaWidth / (N-1); if(px >= bgX) ctx.lineTo(px, centerY + y[i]); }
          ctx.lineTo(margin + waveAreaWidth, 0); ctx.clip();
          ctx.drawImage(imgSky, bgX, (centerY - SKY_IMG_HEIGHT/2) +25, bgW, SKY_IMG_HEIGHT); ctx.restore();
        }
        ctx.strokeStyle = "#ccc"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(margin, centerY - limit); ctx.lineTo(margin, centerY + limit); ctx.stroke();
        ctx.strokeStyle = "black"; ctx.lineWidth = 2; ctx.beginPath(); for(let i=0;i<N;i++) ctx.lineTo(margin + i*waveAreaWidth/(N-1), centerY + y[i]); ctx.stroke();
        ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(margin, centerY + y[0], 6, 0, Math.PI*2); ctx.fill();
      } else {
        const h = 24, sliceW = waveAreaWidth / (N - 1);
        if (showBackground) {
          ctx.save(); ctx.globalAlpha = 0.5;
          const targetX = margin + limit, targetY = centerY - MUSICAL_IMG_HEIGHT / 2, targetW = waveAreaWidth - limit, targetH = MUSICAL_IMG_HEIGHT;
          ctx.beginPath(); ctx.rect(targetX, targetY, targetW, targetH); ctx.clip();
          const imgW = imgMusical.width || 100, imgH = imgMusical.height || 100, imgAspect = imgW / imgH;
          let dW, dH, dX, dY;
          if ((targetW/targetH) > imgAspect) { dW = targetW; dH = targetW / imgAspect; } else { dH = targetH; dW = targetH * imgAspect; }
          dX = targetX + (targetW - dW) / 2; dY = targetY + (targetH - dH) / 2;
          ctx.drawImage(imgMusical, dX, dY, dW, dH); ctx.restore();
          ctx.drawImage(imgPlay, margin + limit + 25, centerY + 40, 150, 150);
          if (noteFade > 0) { ctx.save(); ctx.globalAlpha = (0.55 + 0.15 * Math.sin(Date.now() / 250)) * noteFade; ctx.drawImage(imgNote, margin + limit + 200, centerY + 50, 130, 130); ctx.restore(); }
        }
        ctx.strokeStyle = "#ccc"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(margin - limit, centerY); ctx.lineTo(margin + limit, centerY); ctx.stroke();
        for (let i = 0; i < N - 1; i++) {
          const dx = ((i + 1) * sliceW + y[i + 1]) - (i * sliceW + y[i]);
          const compression = sliceW / dx;
          let gray = compression >= 1.0 ? Math.floor(180 - Math.min(1.0, (compression - 1.0) * 3.0) * 100) : Math.floor(230 + Math.min(1.0, (1.0 - compression) * 3.0) * 25);
          let alpha = compression >= 1.0 ? Math.min(1.0, (compression - 1.0) * 3.0) * 0.35 : Math.min(1.0, (1.0 - compression) * 3.0) * 0.15;
          ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${alpha})`;
          ctx.fillRect(margin + i * sliceW + y[i], centerY - h/2, (sliceW + (y[i+1]-y[i])) + 1, h);
        }
        ctx.fillStyle = "#112244"; for (let i = 0; i < N; i += 2) { const px = margin + i * waveAreaWidth / (N - 1) + y[i]; ctx.beginPath(); ctx.arc(px, centerY, 2.5, 0, Math.PI * 2); ctx.fill(); }
        ctx.fillStyle = "#007bff"; ctx.beginPath(); ctx.arc(margin + y[0], centerY, 9, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
        if(endType === "fixed"){ ctx.fillStyle = "#aaa"; ctx.fillRect(margin + waveAreaWidth, centerY - 40, 4, 80); }
      }
    }

    function loop(){ update(); draw(); requestAnimationFrame(loop); }
    updateManualText(); resetWave(); loop();
  </script>
</body>
</html>