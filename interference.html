<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>なみの重なり(干渉)</title>
<style>
  :root { --active-purple: #e9e5ff; }
  body {
    background-color: #f8fafc; margin: 0; min-height: 100vh;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    font-family: system-ui, sans-serif; user-select: none; overflow: hidden; touch-action: none;
    color: #000000;
  }
  /* --- ロード画面 --- */
  #loading { position: fixed; top:0; left:0; width:100%; height:100%; background:white; display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:99999; transition:opacity 0.8s ease; }
  .logo-container { position: relative; }
  #loading img { width: 180px; height: auto; display: block; }
  .loading-text { position:absolute; right:0; bottom:-25px; font-size:14px; font-weight:bold; color:#555; animation:blink 1.2s infinite; }
  @keyframes blink { 0%,100%{opacity:1;} 50%{opacity:0.1;} }
  #loading.fade-out { opacity:0; pointer-events:none; }
  #loading.hide { display: none !important; }

  /* --- ボタン --- */
  button { background-color:#ffffff !important; color:#000 !important; border:3px solid #000 !important; font-weight:bold; cursor:pointer; transition:0.1s; }
  button:not(.no-color):active, button.active { background-color:var(--active-purple) !important; }
  .no-color:active { background-color:#ffffff !important; }
  button:disabled { cursor: not-allowed; opacity: 0.7; background-color: #f1f5f9 !important; border-color: #ccc !important; }
  .disabled-text { font-size: 10px; font-weight: normal; color: #888; display: block; line-height: 1.3; }

  /* --- レイアウト --- */
  #homeBtn { position: fixed; top: 10px; right: 10px; z-index: 10000; text-decoration:none; color:#000; width:90px; height:40px; border:2px solid black; border-radius:10px; background:white; display:flex; align-items:center; justify-content:center; }
  #analysisLegend { position: fixed; top:10px; left:10px; z-index:10000; background: rgba(255,255,255,0.95); padding:8px 12px; border:2px solid black; border-radius:10px; font-size:12px; display:none; }
  .wrapper { width: 100%; display:flex; justify-content:flex-start; padding-left:40px; box-sizing:border-box; }
  .main-layout { position: relative; display:flex; align-items:center; gap:30px; padding:60px 30px 40px 30px; background:#fff; border:2px solid #000; border-radius:20px; }
  
  .canvas-container { position: relative; width: 450px; height: 450px; border:5px solid #000; background:#e0f2f7; border-radius:12px; transition:transform .5s, background .5s, border-color .5s; overflow:visible; }
  .canvas-container.mode-3d { transform: perspective(1000px) rotateX(35deg); background: transparent !important; border-color: transparent !important; }
  
  #stage { display:block; width:450px; height:450px; border-radius:8px; transition: opacity 0.5s; image-rendering: pixelated; }
  .mode-3d #stage { opacity: 0; pointer-events: none; }

  /* ★追加：グレーの水平直線（ガイドライン） */
  .v-guide {
    position: absolute; left: 0; width: 100%; height: 2px;
    background: rgba(128, 128, 128, 0.5); top: -21px;
    display: none; z-index: 1; pointer-events: none;
  }

  /* --- 中央ガイドメッセージ --- */
  #play-guide-msg {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.75); color: white; padding: 14px 28px;
    border-radius: 40px; font-weight: bold; pointer-events: none;
    opacity: 0; transition: opacity 0.4s ease; z-index: 2000;
    white-space: nowrap; font-size: 18px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  }
  #play-guide-msg.show { opacity: 1; }

  .control-unit { display:flex; flex-direction:column; align-items:center; gap:20px; width:180px; }
  .dial { fill:#f8fafc; stroke:#000; stroke-width:4; } .inner { fill:#e2e8f0; } .handle{ stroke:#000; stroke-width:7; stroke-linecap:round; }
  .gauge-container{ width:18px; height:130px; background:#cbd5e1; border:2px solid #000; border-radius:10px; overflow:hidden; position:relative; }
  .gauge-bar{ width:100%; height:0%; position:absolute; bottom:0; } #gauge1{ background:#ef4444; } #gauge2{ background:#3b82f6; }
  .valve-btn{ width:100%; padding:12px 0; font-size:16px; border-radius:10px; margin-top:5px; }

  .right-ui-container{ position:absolute; right:20px; bottom:40px; z-index:9999; }
  .btn-frame{ display:flex; flex-direction:column; gap:10px; padding:12px; border:3px solid #000; border-radius:16px; background:#f1f5f9; }
  .side-menu button{ width:135px; padding:12px 0; font-size:15px; border-radius:12px; }

  #wire-svg { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:20; }
  .nozzle{ position:absolute; width:28px; height:42px; top:-18px; transform:translateX(-50%); z-index:10; cursor:ew-resize; }
  .nozzle-stick{ width:10px; height:38px; margin:0 auto; border-radius:0 0 5px 5px; border:2px solid #000; }
  #stick1{ background:#ef4444; } #stick2{ background:#3b82f6; }

  .drag-guide {
    position: absolute; top: -55px; left: 50%; transform: translateX(-50%);
    color: #64748b; font-size: 32px; font-weight: bold; white-space: nowrap; pointer-events: none;
    transition: opacity 0.8s ease; text-shadow: 2px 2px 0px #fff; animation: guide-blink 2s infinite; z-index: 30;
  }
  @keyframes guide-blink { 0%, 100% { opacity: 0.3; transform: translateX(-50%) scale(0.9); } 50% { opacity: 1; transform: translateX(-50%) scale(1.1); } }
  .drop { position: absolute; width: 6px; height: 10px; background: #cbd5e1; border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%; z-index: 5; pointer-events: none; box-shadow: inset -1px -1px 2px rgba(0,0,0,0.2); }
</style>
</head>
<body>

<div id="loading">
  <div class="logo-container">
    <img src="SCOPEロゴ通常版-768x768.webp" alt="SCOPEロゴ">
    <div class="loading-text">LOADING...</div>
  </div>
</div>

<div id="analysisLegend">
  <span style="color:#ef4444; font-weight:bold;">■</span> <ruby>赤<rt>あか</rt></ruby>：<ruby>強<rt>つよ</rt></ruby>め<ruby>合<rt>あ</rt></ruby>うところ<br>
  <span style="color:#94a3b8; font-weight:bold;">■</span> <ruby>白<rt>しろ</rt></ruby>：<ruby>消<rt>き</rt></ruby>え<ruby>合<rt>あ</rt></ruby>うところ
</div>

<a href="index.html" id="homeBtn">ホーム</a>

<div class="right-ui-container">
  <div class="side-menu">
    <div class="btn-frame">
      <button class="no-color" onclick="alert('【使い方】\n左右のバルブを回すかボタンで波を大きくします。\nノズルを動かして干渉の変化を観察しましょう。')"><ruby>使<rt>つか</rt></ruby>い<ruby>方<rt>かた</rt></ruby></button>
      <button id="btnExplanation" onclick="alert('【解説】\n2つの波が重なり合うとき、山と山が重なると大きな波になり、山と谷が重なると波が打ち消し合います。これを干渉と呼びます。')"><ruby>解説<rt>かいせつ</rt></ruby></button>
      <button id="btnAnalysis" onclick="toggleAnalysis()"><ruby>調<rt>しら</rt></ruby>べる</button>
      <button id="btn3D" onclick="toggle3D()">3D<ruby>表示<rt>ひょうじ</rt></ruby></button>
    </div>
    <div class="btn-frame">
      <button id="btnPlay" class="active" onclick="togglePlay()">▶ ⏸</button>
      <button id="btnSlow" onclick="toggleSlow()">スロー</button>
      <button class="no-color" onclick="handleReset()">リセット</button>
    </div>
  </div>
</div>

<h2>なみの<ruby>重<rt>かさ</rt></ruby>なり（<ruby>干渉<rt>かんしょう</rt></ruby>）</h2>

<div class="wrapper">
  <div class="main-layout" id="main-ui">
    <svg id="wire-svg">
      <path id="path1" d="" stroke="#ef4444" stroke-width="5" fill="none" stroke-linecap="round"></path>
      <path id="path2" d="" stroke="#3b82f6" stroke-width="5" fill="none" stroke-linecap="round"></path>
    </svg>
    <div class="control-unit">
      <div style="display:flex; align-items:center;">
        <div id="v1-area">
          <svg width="120" height="120" viewBox="0 0 300 300">
            <circle cx="150" cy="150" r="120" class="dial"/><circle cx="150" cy="150" r="70" class="inner"/>
            <g id="ticks1"></g>
            <g id="rot1">
              <line x1="150" y1="30" x2="150" y2="270" class="handle"/><line x1="30" y1="150" x2="270" y2="150" class="handle"/>
              <circle cx="150" cy="30" r="14" style="fill:#ef4444; stroke:#000; stroke-width:3;"></circle>
            </g>
          </svg>
        </div>
        <div id="g1-area"><div class="gauge-container"><div id="gauge1" class="gauge-bar"></div></div></div>
      </div>
      <button class="valve-btn" onmousedown="startBtn(1,1)" ontouchstart="startBtn(1,1)"><ruby>開<rt>あ</rt></ruby>ける</button>
      <button class="valve-btn" onmousedown="startBtn(1,-1)" ontouchstart="startBtn(1,-1)"><ruby>閉<rt>し</rt></ruby>める</button>
    </div>
    <div class="canvas-container" id="water-tank">
      <canvas id="stage" width="225" height="225"></canvas>
      <div id="gl-canvas-container" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;"></div>
      
      <div id="guide-line" class="v-guide"></div>

      <div id="play-guide-msg"><ruby>再生<rt>さいせい</rt></ruby>ボタンを<ruby>押<rt>お</rt></ruby>してね！</div>

      <div id="nozzle1" class="nozzle" style="left:30%;">
        <div class="drag-guide">↔</div>
        <div class="nozzle-stick" id="stick1"></div>
      </div>
      
      <div id="nozzle2" class="nozzle" style="left:70%;">
        <div class="drag-guide">↔</div>
        <div class="nozzle-stick" id="stick2"></div>
      </div>
    </div>
    <div class="control-unit">
      <div style="display:flex; align-items:center;">
        <div id="v2-area">
          <svg width="120" height="120" viewBox="0 0 300 300">
            <circle cx="150" cy="150" r="120" class="dial"/><circle cx="150" cy="150" r="70" class="inner"/>
            <g id="ticks2"></g>
            <g id="rot2">
              <line x1="150" y1="30" x2="150" y2="270" class="handle"/><line x1="30" y1="150" x2="270" y2="150" class="handle"/>
              <circle cx="150" cy="30" r="14" style="fill:#3b82f6; stroke:#000; stroke-width:3;"></circle>
            </g>
          </svg>
        </div>
        <div id="g2-area"><div class="gauge-container"><div id="gauge2" class="gauge-bar"></div></div></div>
      </div>
      <button class="valve-btn" onmousedown="startBtn(2,1)" ontouchstart="startBtn(2,1)"><ruby>開<rt>あ</rt></ruby>ける</button>
      <button class="valve-btn" onmousedown="startBtn(2,-1)" ontouchstart="startBtn(2,-1)"><ruby>閉<rt>し</rt></ruby>める</button>
    </div>
  </div>
</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script>
  (function() {
    const loadingEl = document.getElementById("loading");
    if (sessionStorage.getItem("skipLoad")) {
      loadingEl.classList.add("hide");
      sessionStorage.removeItem("skipLoad");
      return;
    }
    const startTime = Date.now();
    window.addEventListener("load", () => {
      const elapsed = Date.now() - startTime;
      const delay = Math.max(0, 1000 - elapsed);
      setTimeout(() => {
        loadingEl.classList.add("fade-out");
        setTimeout(() => loadingEl.classList.add("hide"), 800);
      }, delay);
    });
  })();

  function handleReset() { sessionStorage.setItem("skipLoad", "true"); location.reload(); }

  let nozzleGuided = false;
  function hideNozzleGuides() {
    if (nozzleGuided) return;
    document.querySelectorAll('.drag-guide').forEach(el => { el.style.animation = 'none'; el.style.opacity = '0'; });
    nozzleGuided = true;
  }

  const canvas2d = document.getElementById('stage');
  const ctx = canvas2d.getContext('2d', { alpha: false });
  const W = 225, H = 225, waveSpeed = 1.7; 
  let isPlaying = true, isSlow = false, isAnalysis = false, is3D = false;

  const state = {
    v1: { angle: 0, x: 67, btnDir: 0, dragMode: null, lastA: 0 },
    v2: { angle: 0, x: 157, btnDir: 0, dragMode: null, lastA: 0 },
    ptr: 0,
    history1: new Float32Array(3000), history2: new Float32Array(3000),
    xHistory1: new Float32Array(3000), xHistory2: new Float32Array(3000),
    phase1: 0, phase2: 0, drops: []
  };

  function togglePlay() { 
    isPlaying = !isPlaying; 
    document.getElementById('btnPlay').classList.toggle('active', isPlaying);
    if(isPlaying) document.getElementById('play-guide-msg').classList.remove('show');
  }
  function toggleSlow() { isSlow = !isSlow; document.getElementById('btnSlow').classList.toggle('active', isSlow); }
  function toggleAnalysis() { isAnalysis = !isAnalysis; document.getElementById('btnAnalysis').classList.toggle('active', isAnalysis); document.getElementById('analysisLegend').style.display = isAnalysis ? 'block' : 'none'; }

  let threeState = { renderer: null, scene: null, camera: null, mesh: null, geometry: null, material: null, glCanvas: null, widthSeg: 0, heightSeg: 0, zScale: 0.6 };

  function toggle3D() {
    const tank = document.getElementById('water-tank');
    const btnAna = document.getElementById('btnAnalysis');
    tank.classList.toggle('mode-3d');
    document.getElementById('btn3D').classList.toggle('active');
    is3D = tank.classList.contains('mode-3d');

    // ★追加：3Dモードのときだけ水平直線を表示
    document.getElementById('guide-line').style.display = is3D ? 'block' : 'none';

    if (is3D) {
      initThreeIfNeeded(); isAnalysis = false;
      btnAna.classList.remove('active'); btnAna.disabled = true;
      btnAna.innerHTML = `<span class="disabled-text">3D<ruby>機能中<rt>きのうちゅう</rt></ruby>は<ruby>使用不可<rt>しようふか</rt></ruby></span>`;
      document.getElementById('analysisLegend').style.display = 'none';
    } else {
      state.drops.forEach(d => d.el.remove()); state.drops = []; disposeThree();
      btnAna.disabled = false; btnAna.innerHTML = `<ruby>調<rt>しら</rt></ruby>べる`;
    }
  }

  [1,2].forEach(id => {
    const layer = document.getElementById('ticks' + id);
    for (let i = 0; i < 12; i++) {
      const rad = (i * 30) * Math.PI / 180;
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", 150 + 120 * Math.cos(rad)); line.setAttribute("y1", 150 + 120 * Math.sin(rad));
      line.setAttribute("x2", 150 + 135 * Math.cos(rad)); line.setAttribute("y2", 150 + 135 * Math.sin(rad));
      line.setAttribute("stroke", "#000"); line.setAttribute("stroke-width", "4"); layer.appendChild(line);
    }
  });

  let msgTimer = null;
  function startBtn(id, d) { 
    state['v'+id].btnDir = d; 
    if(!isPlaying) {
      const msg = document.getElementById("play-guide-msg");
      msg.classList.add("show");
      if(msgTimer) clearTimeout(msgTimer);
      msgTimer = setTimeout(() => msg.classList.remove("show"), 1500); 
    }
  }

  window.addEventListener('mouseup', () => { state.v1.btnDir = state.v2.btnDir = 0; });

  function setupInteraction(id) {
    const vArea = document.getElementById(`v${id}-area`), gArea = document.getElementById(`g${id}-area`);
    const nozzle = document.getElementById(`nozzle${id}`), tank = document.getElementById('water-tank'), v = state[`v${id}`];
    const getAngle = (e) => {
      const rect = vArea.getBoundingClientRect();
      const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
      const clX = (e.touches ? e.touches[0].clientX : e.clientX), clY = (e.touches ? e.touches[0].clientY : e.clientY);
      let a = Math.atan2(clY - cy, clX - cx) * 180 / Math.PI + 90; return a < 0 ? a + 360 : a;
    };
    vArea.addEventListener('mousedown', (e) => { v.dragMode = 'V'; v.lastA = getAngle(e); });
    vArea.addEventListener('touchstart', (e) => { v.dragMode = 'V'; v.lastA = getAngle(e); e.preventDefault(); }, {passive: false});
    gArea.addEventListener('mousedown', (e) => { v.dragMode = 'G'; updateG(e); });
    gArea.addEventListener('touchstart', (e) => { v.dragMode = 'G'; updateG(e); e.preventDefault(); }, {passive: false});
    function updateG(e) {
      const rect = gArea.querySelector('.gauge-container').getBoundingClientRect();
      const clY = (e.touches ? e.touches[0].clientY : e.clientY);
      v.angle = Math.max(0, Math.min(360, (1 - (clY - rect.top) / rect.height) * 360));
    }
    nozzle.addEventListener('mousedown', () => { hideNozzleGuides(); v.dragMode = 'N'; });
    nozzle.addEventListener('touchstart', () => { hideNozzleGuides(); v.dragMode = 'N'; }, {passive: false});
    
    const globalMove = (e) => {
      if (!v.dragMode) return;
      const clX = (e.touches ? e.touches[0].clientX : e.clientX);
      if (v.dragMode === 'V') {
        const cur = getAngle(e); let d = cur - v.lastA; if (d > 180) d -= 360; else if (d < -180) d += 360;
        v.angle = Math.max(0, Math.min(360, v.angle + d)); v.lastA = cur;
      } else if (v.dragMode === 'G') updateG(e);
      else if (v.dragMode === 'N') {
        const rect = tank.getBoundingClientRect();
        v.x = Math.max(0, Math.min(W, (clX - rect.left) / 2));
        nozzle.style.left = (v.x / W * 100) + "%";
      }
      if(e.touches) e.preventDefault();
    };
    window.addEventListener('mousemove', globalMove);
    window.addEventListener('touchmove', globalMove, {passive: false});
    window.addEventListener('mouseup', () => v.dragMode = null);
    window.addEventListener('touchend', () => v.dragMode = null);
  }
  [1,2].forEach(setupInteraction);

  function initThreeIfNeeded() {
    if (threeState.renderer) return;
    const glContainer = document.getElementById('gl-canvas-container');
    const glCanvas = document.createElement('canvas');
    glCanvas.style.width = '100%'; glCanvas.style.height = '100%';
    glContainer.appendChild(glCanvas);
    threeState.glCanvas = glCanvas;
    const renderer = new THREE.WebGLRenderer({ canvas: glCanvas, antialias: true, alpha: true });
    renderer.setSize(glContainer.clientWidth, glContainer.clientHeight, false);
    threeState.renderer = renderer;
    const scene = new THREE.Scene(); threeState.scene = scene;
    const camera = new THREE.PerspectiveCamera(45, glContainer.clientWidth / glContainer.clientHeight, 1, 5000);
    camera.position.set(W/2, -350, 300); camera.up.set(0,0,1); camera.lookAt(new THREE.Vector3(W/2, H/2, 0));
    threeState.camera = camera;
    scene.add(new THREE.AmbientLight(0xffffff, 0.4)); 
    const dir = new THREE.DirectionalLight(0xffffff, 1.5); 
    dir.position.set(W/2, -H, 200); 
    scene.add(dir);
    const widthSeg = 80, heightSeg = 80;
    threeState.widthSeg = widthSeg; threeState.heightSeg = heightSeg;
    const geom = new THREE.PlaneGeometry(W*1.5, H*1.5, widthSeg - 1, heightSeg - 1);
    const mat = new THREE.MeshPhongMaterial({ 
      color: 0x0077be, 
      shininess: 100, 
      specular: 0x444444, 
      side: THREE.DoubleSide 
    });
    const mesh = new THREE.Mesh(geom, mat); mesh.position.set(W/2, H/2, 0); scene.add(mesh);
    threeState.geometry = geom; threeState.material = mat; threeState.mesh = mesh;
  }

  function disposeThree() {
    if (!threeState.renderer) return;
    if (threeState.glCanvas && threeState.glCanvas.parentNode) threeState.glCanvas.parentNode.removeChild(threeState.glCanvas);
    threeState.geometry.dispose(); threeState.material.dispose(); threeState.renderer.dispose();
    threeState.renderer = null;
  }

  function updateThreeMeshFromState() {
    if (!threeState.mesh) return;
    const pos = threeState.geometry.attributes.position.array;
    const cols = threeState.widthSeg, rows = threeState.heightSeg, zScale = threeState.zScale;
    const meshW = W * 1.5, meshH = H * 1.5;
    for (let iy = 0; iy < rows; iy++) {
      const worldY = (iy / (rows - 1)) * meshH - meshH/2 + H/2;
      for (let ix = 0; ix < cols; ix++) {
        const worldX = (ix / (cols - 1)) * meshW - meshW/2 + W/2;
        const calcWave = (id) => {
          const v = state[`v${id}`], hist = state[`history${id}`], xHist = state[`xHistory${id}`];
          const d_now = Math.hypot(worldX - v.x, worldY);
          let t = (state.ptr - Math.round(d_now / waveSpeed) + 3000) % 3000;
          const d_real = Math.hypot(worldX - xHist[t], worldY);
          t = (state.ptr - Math.round(d_real / waveSpeed) + 3000) % 3000;
          const finalD = Math.hypot(worldX - xHist[t], worldY);
          return hist[t] * (10000 / (finalD + 150));
        };
        pos[(iy * cols + ix) * 3 + 2] = (calcWave(1) + calcWave(2)) * zScale;
      }
    }
    threeState.geometry.attributes.position.needsUpdate = true;
    threeState.geometry.computeVertexNormals();
  }

  function spawnDrop(x) {
    if (!is3D) return;
    const div = document.createElement('div');
    div.className = 'drop';
    const startX = (x / W * 100);
    div.style.left = startX + "%"; div.style.top = "20px";
    document.getElementById('water-tank').appendChild(div);
    state.drops.push({ el: div, startX: startX, y: 20, v: 0 });
  }

  function updateDrops() {
    state.drops.forEach((d, i) => {
      d.v += 0.5; d.y += d.v;
      const progress = Math.min(1, (d.y - 20) / 60);
      d.el.style.top = (d.y - progress * 35) + "px";
      d.el.style.opacity = 1 - progress;
      if (d.y > 65) { d.el.remove(); state.drops.splice(i, 1); }
    });
  }

  function draw() {
    try {
      [1, 2].forEach(id => {
        const v = state[`v${id}`];
        if (v.btnDir !== 0) {
          v.angle = Math.max(0, Math.min(360, v.angle + v.btnDir * 3.8));
        }
      });

      let shouldAdvance = isPlaying;
      if (isPlaying && isSlow && Math.random() > 0.25) shouldAdvance = false;
      
      if (shouldAdvance) {
        state.ptr = (state.ptr + 1) % 3000;
        [1, 2].forEach(id => {
          const v = state[`v${id}`];
          const freq = v.angle === 0 ? 0 : 0.12 + (v.angle / 360) * 0.45;
          const oldPhase = state['phase'+id];
          state['phase'+id] += freq;
          state['history'+id][state.ptr] = v.angle > 0 ? Math.sin(state['phase'+id]) : 0;
          state['xHistory'+id][state.ptr] = v.x;
          if (is3D && v.angle > 15 && Math.sin(oldPhase) < 0 && Math.sin(state['phase'+id]) >= 0) {
            spawnDrop(v.x);
          }
        });
        if (is3D) updateDrops();
      }

      [1, 2].forEach(id => {
        const v = state[`v${id}`], nozzle = document.getElementById(`nozzle${id}`), stick = document.getElementById(`stick${id}`), path = document.getElementById(`path${id}`);
        const wobble = (shouldAdvance && v.angle > 0) ? state['history'+id][state.ptr] * 3 : 0;
        nozzle.style.top = (-18 + wobble) + "px";
        const vArea = document.getElementById(`v${id}-area`), mainRect = document.getElementById('main-ui').getBoundingClientRect();
        const vaRect = vArea.getBoundingClientRect(), stRect = stick.getBoundingClientRect();
        const xS = vaRect.left + vaRect.width/2 - mainRect.left, yS = vaRect.top - mainRect.top; 
        const xE = stRect.left + stRect.width/2 - mainRect.left, yE = stRect.top - mainRect.top;
        path.setAttribute("d", `M ${xS} ${yS} C ${xS} 20, ${xS + (id===1?40:-40)} 20, ${(xS + xE)/2} 30 C ${xE} 30, ${xE} ${yE-5}, ${xE} ${yE}`);
        document.getElementById(`rot${id}`).setAttribute("transform", `rotate(${v.angle} 150 150)`);
        document.getElementById(`gauge${id}`).style.height = (v.angle/360*100) + "%";
      });

      if (is3D && threeState.renderer) {
        updateThreeMeshFromState(); threeState.renderer.render(threeState.scene, threeState.camera);
      } else {
        const imgData = ctx.createImageData(W, H), data = imgData.data;
        const curFreq1 = 0.12 + (state.v1.angle / 360) * 0.45, curFreq2 = 0.12 + (state.v2.angle / 360) * 0.45;
        const avgL = (state.v1.angle > 5 && state.v2.angle > 5) ? (2 * Math.PI * waveSpeed) / ((curFreq1 + curFreq2) / 2) : 0;
        
        for (let y = 0; y < H; y++) {
          for (let x = 0; x < W; x++) {
            const calcDisp = (id) => {
              const v = state[`v${id}`], hist = state[`history${id}`], xHist = state[`xHistory${id}`];
              const d_now = Math.hypot(x - v.x, y);
              let t = (state.ptr - Math.round(d_now / waveSpeed) + 3000) % 3000;
              const d_real = Math.hypot(x - xHist[t], y);
              t = (state.ptr - Math.round(d_real / waveSpeed) + 3000) % 3000;
              const finalD = Math.hypot(x - xHist[t], y);
              return { val: hist[t] * (10000 / (finalD + 150)), d: finalD };
            };
            const w1 = calcDisp(1), w2 = calcDisp(2);
            const sum = w1.val + w2.val;
            
            let r = 180 - sum, g = 215 - sum * 0.8, b = 240 - sum * 0.2;

            if (isAnalysis && avgL > 0) {
              const diff = Math.abs(w1.d - w2.d) / avgL;
              const antinodeDist = Math.abs(diff - Math.round(diff));
              const antinodeStrength = Math.exp(-Math.pow(antinodeDist / 0.12, 2));
              const nodeDist = Math.abs(diff - (Math.floor(diff) + 0.5));
              const nodeStrength = Math.exp(-Math.pow(nodeDist / 0.10, 2));

              if (antinodeStrength > 0.05) {
                const alphaR = 0.7 * antinodeStrength;
                r = r * (1 - alphaR) + 255 * alphaR; g = g * (1 - alphaR) + 20 * alphaR; b = b * (1 - alphaR) + 20 * alphaR;
              }
              if (nodeStrength > 0.05) {
                const alphaW = 0.6 * nodeStrength;
                r = r * (1 - alphaW) + 255 * alphaW; g = g * (1 - alphaW) + 255 * alphaW; b = b * (1 - alphaW) + 255 * alphaW;
              }
            }
            const i = (y * W + x) * 4; data[i]=r; data[i+1]=g; data[i+2]=b; data[i+3]=255;
          }
        }
        ctx.putImageData(imgData, 0, 0);
      }
    } catch (e) { }
    requestAnimationFrame(draw);
  }
  draw();
</script>
</body>
</html>